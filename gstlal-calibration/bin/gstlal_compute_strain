#!/usr/bin/env python
#
# Copyright (C) 2010-2014  Jordi Burguet-Castell, Madeline Wade
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")

import gst
import sys
import os
import numpy
import time

from optparse import OptionParser, Option

from gstlal import pipeparts
from gstlal import reference_psd
from gstlal import simplehandler
from gstlal import datasource

from pylal.date import XLALUTCToGPS
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from glue import segments

def psd_resolution_changed(elem, pspec, psd):
	# get frequency resolution and number of bins
	delta_f = elem.get_property("delta-f")
	n = int(round(elem.get_property("f-nyquist") / delta_f) + 1)
	# interpolate and install PSD
	psd = reference_psd.interpolate_psd(psd, delta_f)
	elem.set_property("mean-psd", psd.data[:n])

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (options.write_pipeline, "PLAYING"), verbose = True)
	
parser = OptionParser(description = __doc__)

#
# Append data source options
#

datasource.append_options(parser)

#
# Append program specific options
#

# These options should be used whether the pipeline runs in recoloring or calibration mode
parser.add_option("--output-channel-name", metavar = "name", help = "The name of the channel in the output frames. The default is the same as the channel name")
parser.add_option("--sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate at which to generate strain data. This should be less than or equal to the sample rate of the measured PSDs provided if the pipeline is operating in recoloring mode, and it should be less than or equal to the sample rate of the error and control signal channels if operating in calibration mode. (Default = 16384 Hz)")
parser.add_option("--lldq-sample-rate", metavar = "Hz", default = 1, type = "int", help = "Sample rate for the outgoing LLD-DQ_VECTOR.  (Default = 1 Hz)")
parser.add_option("--odc-float", action = "store_true", help = "Set this if the data quality vector (ODC) is broadcasted as a float.")
parser.add_option("--required-on", metavar = "bit", type = "int", default = 0x1, help = "Set the bit mask for bits that must be on for the instrument/susbystem to be in science mode. (Default = 0x1)")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", help = "Set the number of seconds for each frame.")
parser.add_option("--frames-per-file", metavar = "count", type = "int", help = "Set the number of frames per frame file.")
parser.add_option("--write-to-shm-partition", metavar = "name", help = "Set the name of the shared memory partition to write to. If this is not provided, frames will be written to a file.")
parser.add_option("--buffer-mode", metavar = "number", type = "int", default = 2, help = "Set the buffer mode for the lvshmsink element. (Default=2)")
parser.add_option("--frame-type", metavar = "name", default = "GSTLAL_CAL", help = "Set the frame type as input to the frame writing element. (Default=GSTLAL_CAL)")
parser.add_option("--output-path", metavar = "name", default = ".", help = "Set the output path for writing frame files. (Default=Current)")
parser.add_option("--no-dq-vector", action = "store_true", help = "Set this if you want to turn off all interpretation and calculation of a data quality vector.")

# These are debugging options that can be used in either calibration or recoloring mode
parser.add_option("--write-pipeline", metavar = "filename", help = "Write a DOT graph description of the as-built pipeline to this file (optional).  The environment variable GST_DEBUG_DUMP_DOT_DIR must be set for this option to work.")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

# These are options specific to the recoloring mode of the pipeline
parser.add_option("--recolor", action = "store_true", help = "Recolor data to produce fake strain instead of calibrating to produce real strain. Note: If neither --fake-calibrate or --recolor are turned on, then the pipeline will perform a true strain calibration")
parser.add_option("--reference-psd", metavar = "name", help = "RECOLORING MODE: Set the name of psd xml file to whiten the data with. Use this option if you are whitening with a fixed PSD.")
parser.add_option("--recolor-psd", metavar = "name", help = "RECOLORING MODE: Set the name of psd xml file to recolor the data with")
parser.add_option("--track-psd", action = "store_true", help = "RECOORING MODE: Calculate PSD from input data and track with time. Use this option if you are adaptively whitening.")

# These are options specific to the calibration mode of the pipeline
parser.add_option("--fake-calibrate", action = "store_true", help = "CALIBRATION MODE: Set this option if you would like to fake the calibration process. In this case, one channel will be read in (i.e. the IMC-F_OUT_DQ channel) and tee-ed off three times to fake being the control, error, and excitation signals. The output of this process will not represent anything physical. Note: If neither --fake-calibrate or --recolor are turned on, then the pipeline will perform a true strain calibration.")
parser.add_option("--filters-file", help = "CALIBRATION MODE: Name of file containing filters (in npz format)")
parser.add_option("--wings", type = "int", default = 16, help = "CALIBRATION MODE: Size of wings in seconds.")
parser.add_option("--doubles", action = "store_true", help = "CALIBRATION MODE: Use doubles instead of floats.")
parser.add_option("--time-domain", action = "store_true", help = "CALIBRATION MODE: Apply FIR filters in the time domain.")
parser.add_option("--no-gamma", action = "store_true", help = "CALIBRATION MODE: Set this to turn off the calculation of \gamma from calibration lines.")
parser.add_option("--actuation-sr", type = "int", default = 2048, help = "CALIBRATION MODE: Set the sample rate for the actuation filtering. (Default = 2048 Hz)")
parser.add_option("--darm-ctrl-channel", metavar = "name", default = "LSC-DARM_CTRL", help = "CALIBRATION MODE: Set the name for the control signal channel. (Default: LSC-DARM_CTRL)")
parser.add_option("--darm-err-channel", metavar = "name", default = "LSC-DARM_ERR", help = "CALIBRATION MODE: Set the name of the error signal channel. (Default: LSC-DARM_ERR)")
parser.add_option("--exc-channel", metavar = "name", default = "LSC-DARM_CTRL_EXC_DAQ", help = "CALIBRATION MODE: Set the name of the excitation channel.  This is only necessary when the \gamma factors computation is turned on, which is the default behavior. (Default = LSC-DARM_CTRL_EXC_DAQ)")

#
# Parse options
#

options, filenames = parser.parse_args()

# FIXME: Add in sanity checks for command line options

if options.output_channel_name is None:
	options.output_channel_name = options.channel_name

gw_data_source = datasource.GWDataSourceInfo(options)

if gw_data_source.data_source == "white" and not (options.recolor or options.fake_calibrate):
	raise ValueError("invalid --data-source white; this option can only be used either in --recolor or --fake-calibrate mode")

# Assume instrument is the first (only) key of the channel dict
instrument = gw_data_source.channel_dict.keys()[0]

# Set up short-cut names for each of the sample rates used throughout the pipeline
sr = options.sample_rate
lldqsr = options.lldq_sample_rate
actuationsr = options.actuation_sr

#
# RECOLORING MODE ONLY: Read psd file
#

if options.recolor:
	if options.reference_psd is not None:
		wpsd = reference_psd.read_psd_xmldoc(utils.load_filename(options.reference_psd, verbose = options.verbose, contenthandler = ligolw.LIGOLWContentHandler))[instrument]
	else:
		wpsd = None
		if options.verbose:
			print >>sys.stderr, "No reference PSD provided, whitening will be done on the fly."
	rpsd = reference_psd.read_psd_xmldoc(utils.load_filename(options.recolor_psd, verbose = options.verbose, contenthandler = ligolw.LIGOLWContentHandler))[instrument]

# Set the caps for doubles vs. floats based on the command line option
# FIXME: This pipeline fails in --fake-calibrate mode (at least) when --doubles is not set
if not options.doubles:
	caps = "audio/x-raw-float, width=32, rate=%d" % sr # = 4 bytes, a float
if options.doubles:
	caps = "audio/x-raw-float, width=64, rate=%d" % sr # = 8 bytes, a double

#
# Setup the pipeline
#

pipeline = gst.Pipeline(sys.argv[0])
mainloop = gobject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not options.verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if options.data_source == "lvshm":
	src = pipeparts.mklvshmsrc(pipeline, shm_name = gw_data_source.shm_part_dict[instrument], assumed_duration = 1)
elif options.data_source == "frames":
	src = pipeparts.mklalcachesrc(pipeline, location = gw_data_source.frame_cache, cache_dsc_regex = instrument)
elif options.data_source == "white":
	if options.recolor or options.fake_calibrate:
		rawdata = pipeparts.mkaudiotestsrc(pipeline, wave = 9, samplesperbuffer=sr, blocksize = sr * 4 * 1)
		rawdata = pipeparts.mkcapsfilter(pipeline, rawdata, caps)	
	else:
		raise ValueError("invalid --data-source white; this option can only be used when operating in --recolor or --fake-calibrate mode")

	if not options.no_dq_vector:
		odcstatevector = pipeparts.mkaudiotestsrc(pipeline, wave = 4, samplesperbuffer=sr, blocksize = sr * 4 * 1)
		odcstatevector = pipeparts.mkcapsfilter(pipeline, odcstatevector, "audio/x-raw-float, width=32, rate=%d" % sr)
		odcstatevector = pipeparts.mkgeneric(pipeline, odcstatevector, "exp")
		odcstatevector = pipeparts.mkgeneric(pipeline, odcstatevector, "lal_fixodc")
else:
	raise ValueError("invalid --data-source %s" % options.data_source)

if options.data_source != "white":
	# FIXME: Patch datasource so that you can give it multiple channels to the same instrument. In the meantime, the channel list can only be setup from datasource if one input channel is given (not including the dq channel), which is the case for --recolor and --fake-calibrate mode.
	if options.recolor or options.fake_calibrate:
		channel_list = gw_data_source.channel_dict.items()
	else:
		channel_list = [(instrument, options.darm_ctrl_channel), (instrument, options.darm_err_channel)]
		if not options.no_gamma:
			channel_list.append((instrument, options.exc_channel))
	if not options.no_dq_vector:
		channel_list.append((instrument, gw_data_source.dq_channel_dict[instrument]))
	
	# Hook up the relevant channels to the demuxer
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = True, skip_bad_files = True, channel_list = map("%s:%s".__mod__, channel_list))
	# Write the pipeline graph after pads have been hooked up to the demuxer
	if options.write_pipeline is not None:
		demux.connect("no-more-pads", write_graph)	

	# Set up the appropriate branches within the pipeline
	if options.recolor or options.fake_calibrate:
		rawdata = pipeparts.mkqueue(pipeline, None, max_size_buffers = 0, max_size_time = gst.SECOND * 100)
	else:
		dctrl = pipeparts.mkqueue(pipeline, None, max_size_buffers = 0, max_size_time = gst.SECOND * 100)
		derr = pipeparts.mkqueue(pipeline, None, max_size_buffers = 0, max_size_time = gst.SECOND * 100)
		if not options.no_gamma:
			exc = pipeparts.mkqueue(pipeline, None, max_size_buffers = 0, max_size_time = gst.SECOND * 100)
	if not options.no_dq_vector:
		if options.odc_float:
			odcstatevector = pipeparts.mkgeneric(pipeline, None, "lal_fixodc")
		else:
			odcstatevector = pipeparts.mkreblock(pipeline, None, block_duration = gst.SECOND)

	# Hook up each branch to the appropriate channel in the demuxer
	if options.recolor or options.fake_calibrate:
		pipeparts.src_deferred_link(demux, "%s:%s" % (instrument, gw_data_source.channel_dict[instrument]), rawdata.get_pad("sink"))
	else:
		pipeparts.src_deferred_link(demux, "%s:%s" % (instrument, options.darm_ctrl_channel), dctrl.get_pad("sink"))
		pipeparts.src_deferred_link(demux, "%s:%s" % (instrument, options.darm_err_channel), derr.get_pad("sink"))
		if not options.no_gamma:
			pipeparts.src_deferred_link(demux, "%s:%s" % (instrument, options.exc_channel), exc.get_pad("sink"))
	if not options.no_dq_vector:
		pipeparts.src_deferred_link(demux, "%s:%s" % (instrument, gw_data_source.dq_channel_dict[instrument]), odcstatevector.get_pad("sink"))

# Make sure each of the channels are blocked to no more than 1 second buffers in order to prevent pipeline hang-ups
if options.recolor or options.fake_calibrate:
	rawdata = pipeparts.mkreblock(pipeline, rawdata, block_duration = gst.SECOND)
else:
	dctrl = pipeparts.mkreblock(pipeline, dctrl, block_duration = gst.SECOND)
	derr = pipeparts.mkreblock(pipeline, derr, block_duration = gst.SECOND)
	if not options.no_gamma:
		exc = pipeparts.mkreblock(pipeline, exc, block_duration = gst.SECOND)
if not options.no_dq_vector:
	if options.odc_float:
		odcstatevector = pipeparts.mkreblock(pipeline, odcstatevector, block_duration = gst.SECOND)
	else:
		# If the ODC is ints, change the caps to ensure they are unsigned ints
		# FIXME: When the ODC is written as unsigned ints, this piece can be removed
		odcstatevector = pipeparts.mkaudioconvert(pipeline, odcstatevector)
		odcstatevector = pipeparts.mkcapsfilter(pipeline, odcstatevector, "audio/x-raw-int, signed=false")

# When reading from disk, clip the incoming data stream(s) to segment list
if options.data_source == "frames" and gw_data_source.frame_segments[instrument] is not None:
	if options.recolor or options.fake_calibrate:
		rawdata = pipeparts.mkgate(pipeline, rawdata, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, gw_data_source.frame_segments[instrument]))
	else:
		dctrl = pipeparts.mkgate(pipeline, dctrl, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, gw_data_source.frame_segments[instrument]))
		derr = pipeparts.mkgate(pipeline, derr, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, gw_data_source.frame_segments[instrument]))
		if not options.no_gamma:
			exc = pipeparts.mkgate(pipeline, exc, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, gw_data_source.frame_segments[instrument]))
	# FIXME: This was not here for the dq vector before.  Is there a reason that it wouldn't need to be clipped?
	if not options.no_dq_vector:
		odcstatevector = pipeparts.mkgate(pipeline, odcstatevector, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, gw_data_source.frame_segments[instrument]))

# RECOLORING OR FAKE-CALIBRATE MODE: Make sure the data is in the right format and resample it to the desired sample rate
if options.recolor or options.fake_calibrate:
	#rawdata = pipeparts.mkaudioconvert(pipeline, rawdata)
	rawdata = pipeparts.mkprogressreport(pipeline, rawdata, "progress_src_%s" % instrument)
	rawdata = pipeparts.mkresample(pipeline, rawdata, quality = 9)
	rawdata = pipeparts.mkcapsfilter(pipeline, rawdata, "audio/x-raw-float, rate=%d" % sr)
	rawdata = pipeparts.mkaudiorate(pipeline, rawdata, skip_to_first = True, silent = False) # This audiorate works around a bug in the resampler
	rawdata = pipeparts.mkaudioconvert(pipeline, rawdata)
	rawdata = pipeparts.mkcapsfilter(pipeline, rawdata, caps)
	rawdata = pipeparts.mkchecktimestamps(pipeline, rawdata, "%s_timestamps_%d_hoft" % (instrument, sr))

#
# ODC STATE VECTOR BRANCH
#

if not options.no_dq_vector:
	# FIXME: Should a --required-off be added to the lal_logical_undersampler?
	odcstatevector = pipeparts.mkgeneric(pipeline, odcstatevector, "lal_logical_undersampler", required_on = options.required_on, status_out = 0x3)
	odcstatevector = pipeparts.mkcapsfilter(pipeline, odcstatevector, "audio/x-raw-int, rate=%d" % lldqsr)
	odcstatevector = pipeparts.mkprogressreport(pipeline, odcstatevector, "progress_odc_%s" % instrument)

#
# RECOLORING BRANCH
#

if options.recolor:
	# Whiten the raw data channel and apply recoloring kernel
	rawdata = pipeparts.mkwhiten(pipeline, rawdata, fft_length = 8, zero_pad = 0, average_samples = 64, median_samples = 7, expand_gaps = True, name = "lal_whiten_%s" % instrument)
	if wpsd is None:
		# Use running average PSD
		rawdata.set_property("psd-mode", 0)
	else:
		# Use running PSD
		if options.track_psd:
			rawdata.set_property("psd-mode", 0)
		# Use fixed PSD
		else:
			rawdata.set_property("psd-mode", 1)
		rawdata.connect_after("notify::f-nyquist", psd_resolution_changed, wpsd)
		rawdata.connect_after("notify::delta-f", psd_resolution_changed, wpsd)
	rawdata = pipeparts.mkchecktimestamps(pipeline, rawdata, "%s_timestamps_%d_whitehoft" % (instrument, sr))	

	# Recoloring kernel
	max_sample = int(round(1.0 / rpsd.deltaF * sr / 2.0)) + 1 
	# Truncate to requested output sample rate, if it is higher than the PSD, provides an assert will fail later
	rpsd.data = 1. / rpsd.data[:max_sample]
	fir_matrix, latency, measured_sample_rate = reference_psd.psd_to_fir_kernel(rpsd)
	# Add latency to fix the time stamps
	latency -= 1# FIXME: Remove this if reference_psd.psd_to_fir_kernel() is adjusted
	strain = pipeparts.mkfirbank(pipeline, rawdata, latency = latency, fir_matrix = [fir_matrix], block_stride = sr)

#
# CALIBRATION BRANCH
#

else:
	# If you are operating in --fake-calibrate mode, tee off the incoming data stream into the control signal, error signal, and excitation signal (if applicable)
	if options.fake_calibrate:
		rawdatatee = pipeparts.mktee(pipeline, rawdata)
		dctrl = pipeparts.mkqueue(pipeline, rawdatatee)
		derr = pipeparts.mkqueue(pipeline, rawdatatee)
		if not options.no_gamma:
			exc = pipeparts.mkqueue(pipeline, rawdatatee)

	# Load in the filters file that contains filter coefficients, etc.
	filters = numpy.load(options.filters_file)

	# For comparisons with the second S6 epoch, uncomment the following lines
	olgR = 3.2749237351091275e-2
	olgI = 2.2395752008766873e-1
	wR = 0.0099845355484356
	wI = -0.000556250270852907
	cal_line_freq = 1144.300000

	# If you have a filters file with all of the info in it, uncomment the following lines
	#olgR = filters["olg_re"]
	#olgI = filters["olg_im"]
	#wR = filters["whitener_re"]
	#wI = filters["whitener_im"]
	#cal_line_freq = filters["cal_line_freq"]

	# EXC branch
	if not options.no_gamma:
		exc = pipeparts.mkaudioconvert(pipeline, exc)
		exc = pipeparts.mkcapsfilter(pipeline, exc, caps)
		exc = pipeparts.mkprogressreport(pipeline, exc, "progress_src_exc_%s" % instrument)

	# DARM_ERR branch
	derr = pipeparts.mkaudioconvert(pipeline, derr)
	derr = pipeparts.mkcapsfilter(pipeline, derr, caps)
	derr = pipeparts.mkprogressreport(pipeline, derr, "progress_src_derr_%s" % instrument)
	derr = pipeparts.mkfirbank(pipeline, derr, latency = int(-filters["inv_sens_delay"]), fir_matrix = [filters["inv_sensing"]], time_domain = options.time_domain, block_stride = sr)

	# DARM_CTRL branch
	dctrl = pipeparts.mkaudioconvert(pipeline, dctrl)
	dctrl = pipeparts.mkcapsfilter(pipeline, dctrl, caps)
	dctrl = pipeparts.mkprogressreport(pipeline, dctrl, "progress_src_dctrl_%s" % instrument)
	dctrltee = pipeparts.mktee(pipeline, dctrl)

	dctrl = pipeparts.mkresample(pipeline, pipeparts.mkqueue(pipeline, dctrltee), quality = 9)
	dctrl = pipeparts.mkcapsfilter(pipeline, dctrl, "audio/x-raw-float, rate=%d" % actuationsr)
	dctrl = pipeparts.mkaudiorate(pipeline, dctrl, skip_to_first = True, silent = False)
	dctrl = pipeparts.mkfirbank(pipeline, dctrl, fir_matrix = [filters["actuation"]], time_domain = options.time_domain, block_stride = actuationsr)
	dctrl = pipeparts.mkresample(pipeline, dctrl, quality = 9)
	dctrl = pipeparts.mkcapsfilter(pipeline, dctrl, "audio/x-raw-float, rate=%d" % sr)
	dctrl = pipeparts.mkaudiorate(pipeline, dctrl, skip_to_first = True, silent = False)
	dctrl = pipeparts.mkfirbank(pipeline, dctrl, fir_matrix = [filters["awhitening"]], time_domain = options.time_domain, block_stride = sr)

	# Compute the gamma factors, if applicable
	if not options.no_gamma:
		deltat = 1.0/sr
		cos = pipeparts.mkgeneric(pipeline, None, "lal_numpy_functiongenerator", expression = "%f * cos(2.0 * 3.1415926535897931 * %f * t)" % (deltat, cal_line_freq), blocksize = sr * 4)
		cos = pipeparts.mkcapsfilter(pipeline, cos, caps)

		sin = pipeparts.mkgeneric(pipeline, None, "lal_numpy_functiongenerator", expression = "-1.0 * %f * sin(2.0 * 3.1415926535897931 * %f * t)" % (deltat, cal_line_freq), blocksize = sr*4)
		sin = pipeparts.mkcapsfilter(pipeline, sin, caps)

		compute_gamma_bin = pipeparts.mkcomputegamma(pipeline, pipeparts.mkqueue(pipeline, dctrltee), exc, cos, sin, olgI = olgI, olgR = olgR, sr = sr, time_domain = options.time_domain, wI = wI, wR = wR)
		gammaR = compute_gamma_bin.get_pad("gammaR")
		gammaRtee = pipeparts.mktee(pipeline, gammaR)

		gammaI = compute_gamma_bin.get_pad("gammaI")
		# FIXME: Now you need to do something with each of these gammas in terms of DQ bits
	
		# Mulitiply the derr branch by 1/gamma
		derr_gamma = gst.element_factory_make("lal_multiplier")
		derr_gamma.set_property("sync", True)
		pipeline.add(derr_gamma)
		pipeparts.mkqueue(pipeline, derr, max_size_time = gst.SECOND*100).link(derr_gamma)
		pipeparts.mkqueue(pipeline, pipeparts.mkpow(pipeline, gammaRtee, exponent = -1.0), max_size_time = gst.SECOND*100).link(derr_gamma)

	# Add DARM_ERR and DARM_CTRL to make h(t)
	strain = gst.element_factory_make("lal_adder")
	strain.set_property("sync", True)
	pipeline.add(strain)
	if not options.no_gamma:
		pipeparts.mkqueue(pipeline, derr_gamma, max_size_time = gst.SECOND * 100).link(strain)
	else:
		pipeparts.mkqueue(pipeline, derr, max_size_time = gst.SECOND * 100).link(strain)
	pipeparts.mkqueue(pipeline, dctrl, max_size_time = gst.SECOND * 100).link(strain)
	strain = pipeparts.mkprogressreport(pipeline, strain, "%s_progress_hoft" % instrument)
	
	# FIXME: This sometimes seems to break things, so I've commented it out for now.
	#if options.data_source == "frames":
	#	T = int(options.gps_end_time) - int(options.gps_start_time)
	#	strain = pipeparts.mktrim(pipeline, strain, initial_offset = sr * options.wings, final_offset = sr * (T - options.wings))
	#	strain = pipeparts.mkaudiorate(pipeline, strain, silent = False, skip_to_first = True)	

# Put the units back to strain before writing to frames
# Additionally, override the output channel name if provided from the command line
straintee = pipeparts.mktee(pipeline, strain)
straintagstr = "units=strain,channel-name=%s,instrument=%s" % (options.output_channel_name, instrument)
strain = pipeparts.mktaginject(pipeline, straintee, straintagstr)

if not options.no_dq_vector:

	#
	# H(t)-OK BIT BRANCH
	#

	htdqbit = pipeparts.mkchecktimestamps(pipeline, pipeparts.mkqueue(pipeline, straintee))
	htdqbit = pipeparts.mkbitvectorgen(pipeline, htdqbit, bit_vector = 0x4, nongap_is_control = True)
	htdqbit = pipeparts.mkcapsfilter(pipeline, htdqbit, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % sr)
	htdqbit = pipeparts.mkaudiorate(pipeline, htdqbit, skip_to_first = True, silent = False) # This audiorate fixes issues with zero-sized buffers that are not marked as gaps being passed between the two surrounding elements.  I'm not sure why this is happening, so more work needs to be done to investigate the root of the problem.
	htdqbit = pipeparts.mkgeneric(pipeline, htdqbit, "lal_logical_undersampler", required_on = 0x4, status_out = 0x4)
	htdqbit = pipeparts.mkcapsfilter(pipeline, htdqbit, "audio/x-raw-int, rate=%d, width=32, depth=32, signed=false, channels=1, endianness=1234" % lldqsr)
	htdqbit = pipeparts.mkchecktimestamps(pipeline, htdqbit)

	#
	# COMBINE ODC VECTOR WITH H(t)-OK BIT
	#

	dqvector = gst.element_factory_make("lal_adder")
	dqvector.set_property("sync", True)
	pipeline.add(dqvector)
	pipeparts.mkqueue(pipeline, odcstatevector, max_size_time = gst.SECOND * 100).link(dqvector)
	pipeparts.mkqueue(pipeline, htdqbit, max_size_time = gst.SECOND * 100).link(dqvector)

	dqvector = pipeparts.mkprogressreport(pipeline, dqvector, "progress_llddq_%s" % instrument)
	dqtagstr = "channel-name=%s:LLD-DQ_VECTOR, instrument=%s" % (instrument, instrument)
	dqvector = pipeparts.mktaginject(pipeline, dqvector, dqtagstr)
	dqvector = pipeparts.mkchecktimestamps(pipeline, dqvector)

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

if options.frame_duration is not None:
        mux.set_property("frame-duration", options.frame_duration)
if options.frames_per_file is not None:
        mux.set_property("frames-per-file", options.frames_per_file)

# Link the output DQ vector up to the muxer, if applicable
if not options.no_dq_vector:
	dqvector.get_pad("src").link(mux.get_pad("%s:LLD-DQ_VECTOR" % instrument))

# Link the strain branch to the muxer
pipeparts.mkqueue(pipeline, strain, max_size_time = gst.SECOND * 100).get_pad("src").link(mux.get_pad("%s:%s" % (instrument, options.output_channel_name)))

# Link the real and imaginary gammas to the muxer
if not options.no_gamma and not options.recolor:
	pipeparts.mkqueue(pipeline, gammaRtee).get_pad("src").link(mux.get_pad("%s:GAMMA-REAL" % instrument))
	pipeparts.mkqueue(pipeline, gammaI).get_pad("src").link(mux.get_pad("%s:GAMMA-IMAGINARY" % instrument))

# FIXME: More outputs need to be hooked up to the muxer

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if options.write_to_shm_partition is not None:
	lvshmsink = gst.element_factory_make("gds_lvshmsink")
	lvshmsink.set_property("shm-name", options.write_to_shm_partition)
	lvshmsink.set_property("num-buffers", 10)
	lvshmsink.set_property("blocksize", 405338 * options.frame_duration * options.frames_per_file)
	lvshmsink.set_property("buffer-mode", options.buffer_mode)
	pipeline.add(lvshmsink)
	mux.link(lvshmsink)
else:
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = options.frame_type, path = options.output_path, instrument = instrument) 

# Run pipeline

if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "NULL"), verbose = options.verbose)

if gw_data_source.data_source == "frames":
	datasource.do_seek(pipeline, gw_data_source.seekevent)
	print >>sys.stderr, "seeking GPS start and stop times ..."

# FIXME: Is this right? Should I be seeking the pipeline this way when I'm using lvshmsrc? This part is here to seek the sin and cos elements, but maybe this will screw with how the data is read from shared memory too.
if options.data_source == "white" or (options.data_source == "lvshmsrc" and not options.no_gamma):
	tm = time.gmtime()
	NOW = XLALUTCToGPS(tm).ns()
	seek = gst.event_new_seek(1., gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH | gst.SEEK_FLAG_KEY_UNIT, gst.SEEK_TYPE_SET, NOW, gst.SEEK_TYPE_SET, -1)
	datasource.do_seek(pipeline, seek)	

if options.verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(gst.STATE_PLAYING) == gst.STATE_CHANGE_FAILURE:
	raise RuntimeError("pipeline failed to enter PLAYING state")
if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "PLAYING"), verbose = options.verbose)
	
if options.verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()
