#!/usr/bin/env python
#
# Copyright (C) 2013  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import os
import sys
from optparse import OptionParser


# The following snippet is taken from http://gstreamer.freedesktop.org/wiki/FAQ#Mypygstprogramismysteriouslycoredumping.2Chowtofixthis.3F
import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")
import gst


from gstlal import datasource
from gstlal import pipeparts
from gstlal import simplehandler

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src

def excepthook(*args):
	# system exception hook that forces hard exit.  without this,
	# exceptions that occur inside python code invoked as a call-back
	# from the gstreamer pipeline just stop the pipeline, they don't
	# cause gstreamer to exit.

	# FIXME:  they probably *would* cause if we could figure out why
	# element errors and the like simply stop the pipeline instead of
	# crashing it, as well.  Perhaps this should be removed when/if the
	# "element error's don't crash program" problem is fixed
	sys.__excepthook__(*args)
	os._exit(1)

sys.excepthook = excepthook


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		description = __doc__
	)
	parser.add_option("--output-path", metavar = "path", default = os.environ.get("TMPDIR", "."), help = "Set the path where the output frame files are to be written (default = value of TMPDIR environment variable if set, otherwise the current working directory).")
	parser.add_option("--sample-rate", metavar = "Hz", type = "int", help = "Downsample to this sample rate (default = no resampling).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
	datasource.append_options(parser)

	options, filenames = parser.parse_args()

	options.description = "CBC_TMP"

	try:
		output_cache_filename, = filenames
	except ValueError:
		raise ValueError("must provide exactly one output cache filename")

	return options, output_cache_filename


#
# =============================================================================
#
#                                   Pipeline
#
# =============================================================================
#


class Handler(simplehandler.Handler):
	def __init__(self, *args, **kwargs):
		super(Handler, self).__init__(*args, **kwargs)
		self.cache = []

	def do_on_message(self, bus, message):
		if message.type == gst.MESSAGE_ELEMENT and message.structure.get_name() == "GstMultiFileSink":
			self.cache.append(pipeparts.framecpp_filesink_cache_entry_from_mfs_message(message))

	def write_cache(self, fileobj):
		for cacheentry in self.cache:
			print >>fileobj, str(cacheentry)


def build_pipeline(pipeline, data_source_info, sample_rate = None, channel_comment = None, frame_duration = 1, frames_per_file = 2048, verbose = False):
	#
	# get instrument and channel name (requires exactly one
	# instrument+channel)
	#

	(instrument, channel_name), = data_source_info.channel_dict.items()

	#
	# retrieve h(t)
	#

	src = datasource.mkbasicsrc(pipeline, data_source_info, instrument, verbose = verbose)

	#
	# optionally resample
	#

	if sample_rate is not None:
		# make sure we're *down*sampling
		src = pipeparts.mkcapsfilter(pipeline, src, "audio/x-raw-float, rate=[%d,MAX]" % sample_rate)
		src = pipeparts.mkresample(pipeline, src, quality = 9)
		src = pipeparts.mkcapsfilter(pipeline, src, "audio/x-raw-float, rate=%d" % sample_rate)

	#
	# pack into frame files for output
	#

	src = pipeparts.mkframecppchannelmux(pipeline, {"%s:%s" % (instrument, channel_name): src}, frame_duration = frame_duration, frames_per_file = frames_per_file)
	for pad in src.sink_pads():
		if channel_comment is not None:
			pad.set_property("comment", channel_comment)
		pad.set_property("pad-type", "FrProcData")
	pipeparts.mkframecppfilesink(pipeline, src, frame_type = options.description, path = options.output_path)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# parse command line
#


options, output_cache_filename = parse_command_line()
data_source_info = datasource.GWDataSourceInfo(options)


#
# Build pipeline
#


mainloop = gobject.MainLoop()
pipeline = gst.Pipeline("gstlal_inspiral_condition_data")
handler = Handler(mainloop, pipeline)


if options.verbose:
	print >>sys.stderr, "assembling pipeline ...",
build_pipeline(pipeline, data_source_info, sample_rate = options.sample_rate, channel_comment = "cached h(t) for inspiral search", verbose = options.verbose)
if options.verbose:
	print >>sys.stderr, "done"


#
# Run pipeline
#


if options.verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(gst.STATE_PLAYING) != gst.STATE_CHANGE_SUCCESS:
	raise RuntimeError("pipeline did not enter playing state")

if options.verbose:
	print >>sys.stderr, "running pipeline ..."
mainloop.run()


#
# Write cache
#


if options.verbose:
	print >>sys.stderr, "writing %s ..." % output_cache_filename
handler.write_cache(open(output_cache_filename, "w"))


#
# done
#
