#!/usr/bin/env python
import sys
import scipy
import numpy
import pylab
from optparse import OptionParser
from gstlal.pipeio import repack_complex_array_to_real, repack_real_array_to_complex
from glue import segments
from pylal.datatypes import LIGOTimeGPS
from gstlal import ligolw_output
from pylal.xlal.datatypes.snglinspiraltable import from_buffer as sngl_inspirals_from_buffer

def plot(pipeline, pre_elems, title="gstlal"):
	elems = []
	elems.append(pipeutil.mkelem("queue", {"max-size-time": 2}))
	elems.append(pipeutil.mkelem("cairovis_waterfall", {"title": title, "z-autoscale": True, "colormap": "jet", "history": 10 * gst.SECOND}))
	elems.append(pipeutil.mkelem("capsfilter",{"caps": gst.Caps("video/x-raw-rgb,framerate=12/1,width=800,height=800")}))
	elems.append(pipeutil.mkelem("ximagesink",{"sync": False,"async": False,}))
	for elem in elems: pipeline.add(elem)
	elems = pre_elems + elems
	gst.element_link_many(*elems)

def parse_command_line():
	parser = OptionParser(description = __doc__)
	parser.add_option("--iir-bank", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load the iir template bank (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load the injections (optional).")
	parser.add_option("--gps-start-time", help="GPS start time", type="float")
	parser.add_option("--gps-end-time", help="GPS end time", type="float")
	parser.add_option("--frame-cache", help="frame-cache. If not specified fake data will be used", type="str")
	parser.add_option("--output", metavar = "filename", help = "Set the filename in which to save the triggers (required)")
	parser.add_option("--instrument", metavar="IFO", help="set the instrument default H1", default="H1")
	parser.add_option("--channel-name", metavar="IFO", help="set the channel default LSC-STRAIN", default="LSC-STRAIN")
	parser.add_option("--tmp-space",  metavar="PATH")
	parser.add_option("--comment",  metavar="str")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
	
	options, filenames = parser.parse_args()

	# If --gps-start-time is not specified, assume "beginning of time"
	if options.gps_start_time is None:
		effective_gps_start_time = LIGOTimeGPS(0) # FIXME: should be gobject.G_MININT, but somewhere along the line we have an integer overflow error
	else:
		effective_gps_start_time = LIGOTimeGPS(options.gps_start_time)

	# If --gps-end-time is not specified, assume "end of time"
	if options.gps_end_time is None:
		effective_gps_end_time = LIGOTimeGPS(999999999) # FIXME: should be gobject.G_MAXINT, but somewhere along the line we have an integer overflow error
	else:
		effective_gps_end_time = LIGOTimeGPS(options.gps_end_time)

	process_params = ligolw_output.make_process_params(options)
	options.seg = segments.segment(effective_gps_start_time, effective_gps_end_time)

	return options, filenames, process_params

options, filenames, process_params = parse_command_line()

from gstlal import cbc_template_iir
from gstlal.reference_psd import read_psd
from glue.ligolw import utils, array, param
from gstlal import pipeutil
from gstlal.lloidparts import seek_event_for_gps, mkelems_fast
from gstlal.pipeutil import gobject, gst

# extract parameters from the bank
xmldoc = utils.load_filename(options.iir_bank, gz=options.iir_bank.endswith('.gz'))
A, B, D, autocor = cbc_template_iir.get_matrices_from_xml(xmldoc)

sample_rate = param.get_pyvalue(xmldoc, 'sample_rate')
flower = param.get_pyvalue(xmldoc, 'flower')
coinc_window = 512
coinc_time = 0.03
snr_threshold = 5.0
mean = {}
tee = {}
triggergen = {}
chisq = {}

mainloop = gobject.MainLoop()
pipeline = gst.Pipeline("gstlal_iir_inspiral")

from gstlal.lloidparts import DetectorData

detectors = {
        options.instrument: DetectorData(options.frame_cache, options.channel_name)
}

options.out_seg = segments.segment(options.seg[0], options.seg[1]) #FIXME make better outseg def.
data = ligolw_output.Data(options, detectors)
data.prepare_output_file(process_params)

def appsink_new_buffer(elem, data):
	for row in sngl_inspirals_from_buffer(elem.get_property("last-buffer")):
		if (row.end_time + 1e-9*row.end_time_ns) in data.out_seg:
			row.process_id = data.process.process_id
			row.event_id = data.sngl_inspiral_table.get_next_id()
			data.sngl_inspiral_table.append(row)
	if data.connection: data.connection.commit()


for ifo in [options.instrument]:
	elems = []
	elems.append(pipeutil.mkelem("lal_fakeligosrc", {"channel-name": options.channel_name, "instrument": ifo, "blocksize": 16384 * 8}))
	#elems.append(pipeutil.mkelem("audiotestsrc", {"wave":10, "freq":0.1}))
	elems.append(pipeutil.mkelem("progressreport"))

	# add injection if specified
	if options.injections: elems.append(pipeutil.mkelem("lal_simulation", {"xml-location": options.injections}))

	# resample at the specified sample rate
	elems.append(pipeutil.mkelem("audioresample"))
	elems.append(pipeutil.mkelem("capsfilter",{"caps": gst.Caps("audio/x-raw-float,width=64,rate=%d" % (sample_rate))}))

	# apply whitening and do filtering
	elems.append(pipeutil.mkelem("lal_whiten",{"zero-pad": 0, "fft-length": 8, "average-samples": 32, "median-samples": 9,}))
	elems.append(pipeutil.mkelem("lal_nofakedisconts"))
	elems.append(pipeutil.mkelem("progressreport"))
	elems.append(pipeutil.mkelem("lal_iirbank",{"name": ifo+" iir", "a1-matrix": repack_complex_array_to_real(A), "b0-matrix": repack_complex_array_to_real(B), "delay-matrix":D}))
	elems.append(pipeutil.mkelem("queue"))
	elems.append(pipeutil.mkelem("lal_togglecomplex"))
	elems.append(pipeutil.mkelem("lal_nofakedisconts"))
	elems.append(pipeutil.mkelem("progressreport"))
	tee[ifo] =  pipeutil.mkelem("tee")
	elems.append(tee[ifo])
	for elem in elems: pipeline.add(elem)
	gst.element_link_many(*elems)
	
	triggergen[ifo] = pipeutil.mkelem("lal_triggergen",{"bank-filename":options.iir_bank, "snr-thresh":snr_threshold, "max-gap": 1.0})
	chisq[ifo] = pipeutil.mkelem("lal_autochisq", {"snr-thresh":snr_threshold, "latency": -50, "autocorrelation-matrix":repack_complex_array_to_real(autocor)})
	pipeline.add(chisq[ifo])
	pipeline.add(triggergen[ifo])

	queue = pipeutil.mkelem("queue")
	pipeline.add(queue)
	tee[ifo].link(queue)
	queue.link_pads("src", triggergen[ifo], "snr")
	
	queue = pipeutil.mkelem("queue")
	pipeline.add(queue)
	tee[ifo].link(queue)
	queue.link(chisq[ifo])
	chisq[ifo].link(triggergen[ifo])

	tc = pipeutil.mkelem("lal_togglecomplex")
	pipeline.add(tc)
	nxydump = pipeutil.mkelem("lal_nxydump")
	pipeline.add(nxydump)
	filesink = pipeutil.mkelem("filesink", {"location":"test.txt"})
	pipeline.add(filesink)

	tee[ifo].link(tc)
	tc.link(nxydump)
	nxydump.link(filesink)
	
	appsink = pipeutil.mkelem("appsink",{"caps": gst.Caps("application/x-lal-snglinspiral"), "sync": False, "async": False, "emit-signals": True, "max-buffers": 1, "drop": True})
	pipeline.add(appsink)
	triggergen[ifo].link(appsink)
	appsink.connect_after("new-buffer", appsink_new_buffer, data)
		

############################################################
# run the pipeline

class Handler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
			sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg))


gst.DEBUG_BIN_TO_DOT_FILE(pipeline, gst.DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS, "gstlal_iir_inspiral_graph")

seekevent = seek_event_for_gps(options.gps_start_time, options.gps_end_time)

for src in pipeline.iterate_sources():
	src.send_event(seekevent)

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()

data.write_output_file()
