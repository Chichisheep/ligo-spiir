#!/usr/bin/env python
#
# Copyright (C) 2011  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from gstlal import pipeparts
from gstlal import simplehandler
from gstlal import datasource
from optparse import OptionParser, Option
from glue import segments
from pylal.datatypes import LIGOTimeGPS
import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")
import gst
import sys
import os

parser = OptionParser(description = __doc__)

#
# Append data source options
#

datasource.append_options(parser)

#
# Append program specific options
#

parser.add_option("--frame-type", metavar = "name", help = "Specify the non-instrumental part of the frame type. The full frame type will be constructed by prepending the instrument.")
parser.add_option("--output-channel-name", metavar = "name", help = "If an additional frame cache is requested, indicate the channel name to extract.")
parser.add_option("--output-path", metavar = "name", help = "Path to output frame files.")
parser.add_option("--duration", metavar = "s", default = 64, type = "int", help = "Set the duration of the output frame files")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

options, filenames = parser.parse_args()

gw_data_source = datasource.GWDataSourceInfo(options)

if( options.frame_type is None ):
	exit( "Frame type argument is required." )


pipeline = gst.Pipeline(sys.argv[0])
mainloop = gobject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# Assume instrument is the first (only) key of the channel dict
instrument = gw_data_source.channel_dict.keys()[0]

head = datasource.mkbasicsrc(pipeline, gw_data_source, instrument, verbose = options.verbose)

if options.output_channel_name is not None:
	# Correct the channel name
	head = pipeparts.mktaginject(pipeline, head, "instrument=%s,channel-name=%s,units=strain" % (instrument,options.output_channel_name))

if options.output_path is not None:
	outpath = os.path.join(options.output_path,instrument)
else:
	outpath = instrument

head = pipeparts.mkprogressreport(pipeline, head, "frames")

try:
	os.makedirs(outpath)
except:
	pass

frametype = "%s_%s" % (instrument, options.frame_type)

pipeparts.mkframesink(pipeline, head, path=outpath, sync=False, async=True, duration = options.duration, frame_type=frametype, dir_digits=5)

if pipeline.set_state(gst.STATE_PLAYING) == gst.STATE_CHANGE_FAILURE:
	raise RuntimeError("pipeline failed to enter PLAYING state")

mainloop.run()

