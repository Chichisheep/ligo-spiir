#!/usr/bin/env python
#
# Copyright (C) 2011  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from gstlal import pipeparts
from gstlal import reference_psd
from gstlal import simplehandler
from gstlal import datasource
from gstlal import multirate_datasource
from optparse import OptionParser, Option
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from pylal.datatypes import LIGOTimeGPS
from pylal import series as lalseries
import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")
import gst
import sys
import os

def psd_resolution_changed(elem, pspec, psd):
	# get frequency resolution and number of bins
	delta_f = elem.get_property("delta-f")
	n = int(round(elem.get_property("f-nyquist") / delta_f) + 1)
	# interpolate and install PSD
	print delta_f, n
	psd = reference_psd.interpolate_psd(psd, delta_f)
	elem.set_property("mean-psd", psd.data[:n])

parser = OptionParser(description = __doc__)

#
# Append data source options
#

datasource.append_options(parser)

#
# Append program specific options
#

parser.add_option("--output-channel-name", metavar = "name", help = "The name of the channel in the output frames. The default is the same as the channel name")
parser.add_option("--reference-psd", metavar = "name", help = "Set the name of psd xml file to whiten the data with")
parser.add_option("--recolor-psd", metavar = "name", help = "Set the name of psd xml file to recolor the data with")
parser.add_option("--output-path", metavar = "name", help = "Path to output frame files.")
parser.add_option("--duration", metavar = "s", default = 64, type = "int", help = "Set the duration of the output frame files")
parser.add_option("--track-psd", action = "store_true", help = "Calculate PSD from input data and track with time.")
parser.add_option("--shift", metavar = "ns", help = "Number of nanoseconds to delay (negative) or advance (positive) the time stream", type = "int")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
parser.add_option("--sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate at which to generate the data, should be less than or equal to the sample rate of the measured psds provided, default = 16384 Hz")

#
# Parse options
#

options, filenames = parser.parse_args()

if options.output_channel_name is None:
	options.output_channel_name = options.channel_name

sr = options.sample_rate

gw_data_source = datasource.GWDataSourceInfo(options)

# Assume instrument is the first (only) key of the channel dict
instrument = gw_data_source.channel_dict.keys()[0]

#
# read psd file
#

if options.reference_psd is not None:
	wpsd = lalseries.read_psd_xmldoc(utils.load_filename(options.reference_psd, verbose = options.verbose, contenthandler = ligolw.LIGOLWContentHandler))[instrument]
else:
	wpsd = None
	if options.verbose:
		print >>sys.stderr, "No reference PSD provided, whitening will be done on the fly."
rpsd = lalseries.read_psd_xmldoc(utils.load_filename(options.recolor_psd, verbose = options.verbose, contenthandler = ligolw.LIGOLWContentHandler))[instrument]

#
# Setup the pipeline
#

pipeline = gst.Pipeline(sys.argv[0])
mainloop = gobject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

#
# construct the pipeline framesrc -> whiten -> shift -> firbank (recolor) -> frame sink
#

head = datasource.mkbasicsrc(pipeline, gw_data_source, instrument, verbose = options.verbose)

head = pipeparts.mkprogressreport(pipeline, head, "frames")

if options.shift is not None:
	head = pipeparts.mkshift(pipeline, head, shift = options.shift)
	head = pipeparts.mkprogressreport(pipeline, head, "frames_shifted")

# first whiten and downsample, take only the [sr] item
head = multirate_datasource.mkwhitened_multirate_src(pipeline, head, [sr], instrument, psd = wpsd, seekevent = gw_data_source.seekevent, block_duration = gst.SECOND, track_psd = options.track_psd)[sr]

# Recolor kernel
max_sample = int(round(1.0 / rpsd.deltaF * sr / 2.0)) + 1 
# truncate to requested output sample rate, if it is higher than the psd provides an assert will fail later
rpsd.data = 1. / rpsd.data[:max_sample]
fir_matrix, latency, measured_sample_rate = reference_psd.psd_to_fir_kernel(rpsd)
head = pipeparts.mkfirbank(pipeline, head, latency = latency, fir_matrix = [fir_matrix], block_stride = 32 * sr)

# put the units back to strain before writing to frames
# Additionally, override the output channel name if provided from the command line
tagstr = "units=strain,channel-name=%s,instrument=%s" % (options.output_channel_name, instrument)
head = pipeparts.mktaginject(pipeline, head, tagstr)

if options.injections is not None:
	head = pipeparts.mkinjections(pipeline, head, options.injections)

outfolder = instrument+"-"+options.output_channel_name
if options.output_path is not None:
        outpath = os.path.join(options.output_path,outfolder)
else:
        outpath = outfolder

try:
        os.makedirs(outpath)
except:
        pass

pipeparts.mkframesink(pipeline, head, path=outpath, frame_type=instrument, duration = options.duration)

#
# Run it
#

if pipeline.set_state(gst.STATE_PLAYING) == gst.STATE_CHANGE_FAILURE:
	raise RuntimeError("pipeline failed to enter PLAYING state")

mainloop.run()

