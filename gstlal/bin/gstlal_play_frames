#!/usr/bin/env python
#
# Copyright (C) 2011--2012  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import sys
import numpy

import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require('0.10')
import gst
from gstlal import pipeparts
from gstlal import reference_psd
from gstlal import datasource
from optparse import OptionParser
from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw import lsctables
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
lsctables.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from glue.ligolw.utils import segments as ligolw_segments

class Handler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline
		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()

def parse_command_line():
	parser = OptionParser(description = __doc__)
	parser.add_option("--output", metavar = "filename", help = "Set the filename in which to save the output")
	parser.add_option("--reference-psd", metavar="xml-file", help="reference psd XML file") 
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
	datasource.append_options(parser)

	options, filenames = parser.parse_args()

	return options, filenames


# parsing and setting up some core structures
options, filenames = parse_command_line()

gw_data_source_info = datasource.GWDataSourceInfo(options)

if len(options.channel_name) > 1:
	raise ValueError,"gstlal_play_frames only configured to play data from a single channel"
instrument = gw_data_source_info.channel_dict.keys()[0]

if options.reference_psd is not None:
	psd = reference_psd.read_psd_xmldoc(utils.load_filename(options.reference_psd, verbose = options.verbose, contenthandler = ligolw.LIGOLWContentHandler))[instrument]
else:
	psd = None


# building the event loop and pipeline
gobject.threads_init()
mainloop = gobject.MainLoop()
pipeline = gst.Pipeline("gstlal_play_frames")

# the pipeline

rate = 2048

head = datasource.mkbasicsrc(pipeline, gw_data_source_info, instrument, verbose = options.verbose)
# disallow upsampling
head = pipeparts.mkcapsfilter(pipeline, head, "audio/x-raw-float, rate=[%d,MAX]" % rate)
head = pipeparts.mkresample(pipeline, head, quality = 9)
head = pipeparts.mkcapsfilter(pipeline, head, "audio/x-raw-float, rate=%d" % rate)
head = pipeparts.mkwhiten(pipeline, head)

if psd is None:
	# use running average PSD
	head.set_property("psd-mode", 0)
else:
	head.set_property("psd-mode", 1)

	#
	# install signal handler to retrieve \Delta f and
	# f_{Nyquist} whenever they are known and/or change,
	# resample the user-supplied PSD, and install it into the
	# whitener.
	#

	def psd_resolution_changed(elem, pspec, psd):
		# get frequency resolution and number of bins
		delta_f = elem.get_property("delta-f")
		n = int(round(elem.get_property("f-nyquist") / delta_f) + 1)
		# interpolate and install PSD
		psd = reference_psd.interpolate_psd(psd, delta_f)
		elem.set_property("mean-psd", psd.data[:n])

	head.connect_after("notify::f-nyquist", psd_resolution_changed, psd)
	head.connect_after("notify::delta-f", psd_resolution_changed, psd)

head = pipeparts.mkaudioconvert(pipeline, head)

if options.output.endswith(".wav"):
	head = pipeparts.mkflacenc(pipeline, head)
	pipeparts.mkfilesink(pipeline, head, options.output)
else:
	pipeparts.mknxydumpsink(pipeline, head, "test.txt")

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
