#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import numpy
from optparse import OptionParser
import sys


import gobject
import pygst
pygst.require("0.10")
import gst


gobject.threads_init()


from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import utils
from pylal import series as lalseries
from pylal.datatypes import LALUnit
from pylal.datatypes import LIGOTimeGPS
from pylal.datatypes import REAL8FrequencySeries


from gstlal import pipeparts


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Bank(object):
	class BankFragment(object):
		def __init__(self, rate, start, end, blocksize = None):
			self.rate = rate
			self.start = start
			self.end = end
			self.blocksize = blocksize
			if self.blocksize is None:
				# default = 1 second
				self.blocksize = self.rate

	def __init__(self, template_bank_filename, bank_fragments, gate_threshold, snr_threshold, logname = None):
		self.template_bank_filename = template_bank_filename
		self.bank_fragments = bank_fragments
		self.filter_length = max(fragment.end for fragment in bank_fragments)
		self.gate_threshold = gate_threshold
		self.snr_threshold = snr_threshold
		self.logname = logname

	def get_rates(self):
		return set(bank_fragment.rate for bank_fragment in self.bank_fragments)


class DetectorData(object):
	def __init__(self, frame_cache, channel, reference_psd_filename, block_size = 16384 * 16 * 8):
		self.frame_cache = frame_cache
		self.channel = channel
		self.reference_psd_filename = reference_psd_filename
		# default block_size = 16384 samples/second * 16 seconds *
		# 8 bytes/sample
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


#
# LLOID for one instrument
#


def mkcontrolsnksrc(pipeline, rate, progress_report = False, suffix = None):
	snk = gst.element_factory_make("lal_adder")
	snk.set_property("sync", True)
	pipeline.add(snk)
	src = pipeparts.mkcapsfilter(pipeline, snk, "audio/x-raw-float, rate=%d" % rate)
	if progress_report:
		src = pipeparts.mkprogressreport(pipeline, src, "progress_sumsquares%s" % (suffix and "_%s" % suffix or ""))
	src = pipeparts.mktee(pipeline, src)
	return snk, src


def mkLLOIDsrc(pipeline, instrument, detector, rates, fake_data = False, injection_filename = None, progress_report = False):
	if fake_data:
		head = pipeparts.mkfakeLIGOsrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	else:
		head = pipeparts.mkframesrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	if progress_report:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_src_%s" % instrument)

	if injection_filename is not None:
		head = pipeparts.mkinjections(pipeline, head, injection_filename)

	head = pipeparts.mkwhiten(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % max(rates)))

	correction = {
		128: 1.03 / 0.93,
		256: 1.03 / 0.93,
		512: 1.03 / 0.93,
		2048: 1.03 / 1.03
	}

	hoft = {max(rates): pipeparts.mktee(pipeline, head)}
	for rate in sorted(rates)[:-1]:	# all but the highest rate
		# FIXME:  the default quality is 4, we should try setting
		# it higher (9?), but then the variance correction look-up
		# table will need to be re-measured
		hoft[rate] = pipeparts.mktee(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, pipeparts.mkaudioamplify(pipeline, hoft[max(rates)], math.sqrt(correction[rate] * float(max(rates)) / rate))), "audio/x-raw-float, rate=%d" % rate))

	return hoft


def mkLLOIDsingle(pipeline, hoftdict, instrument, detector, bank, progress_report = False, control_snksrc = None):
	logname = "%s%s" % (instrument, (bank.logname and "_%s" % bank.logname or ""))

	if control_snksrc is None:
		control_snksrc = mkcontrolsnksrc(pipeline, max(bank.get_rates()), progress_report = progress_report, suffix = logname)
		#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, control_snksrc[1]), "sumsquares_%s.txt" % logname)

	snr = gst.element_factory_make("lal_adder")
	snr.set_property("sync", True)
	pipeline.add(snr)

	#chisq = gst.element_factory_make("lal_adder")
	#chisq.set_property("sync", True)
	#pipeline.add(chisq)

	for bank_fragment in bank.bank_fragments:
		#bank_snr, bank_chisq = pipeparts.mkbank_oldchisq(
		bank_snr = pipeparts.mkbank_newchisq(
			pipeline,
			pipeparts.mkqueue(pipeline, hoftdict[bank_fragment.rate], max_size_bytes = 0, max_size_buffers = 0, max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000),
			bank,
			bank_fragment,
			detector.reference_psd_filename,
			control_snksrc[0],
			control_snksrc[1]
		)
		pipeparts.mkqueue(pipeline, bank_snr).link(snr)
		#pipeparts.mkqueue(pipeline, bank_chisq).link(chisq)

	snr = pipeparts.mkcapsfilter(pipeline, snr, "audio/x-raw-float, rate=%d" % max(bank.get_rates()))
	#chisq = pipeparts.mkcapsfilter(pipeline, chisq, "audio/x-raw-float, rate=%d" % max(bank.get_rates()))

	snr = pipeparts.mktee(pipeline, snr)
	chisq = gst.element_factory_make("lal_autochisq")
	chisq.set_property("template-bank", bank.template_bank_filename)
	chisq.set_property("reference-psd", detector.reference_psd_filename)
	pipeline.add(chisq)
	pipeparts.mkqueue(pipeline, snr).link(chisq)

	#snr = pipeparts.mktee(pipeline, snr)
	#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, snr), "snr_%s.txt" % logname)
	#chisq = pipeparts.mktee(pipeline, chisq)
	#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, chisq), "chisquare_%s.txt" % logname)

	#head = pipeparts.mktriggergen(pipeline, snr, chisq, bank.template_bank_filename, bank.snr_threshold)
	head = pipeparts.mktriggergen(pipeline, pipeparts.mkqueue(pipeline, snr), pipeparts.mkqueue(pipeline, chisq), bank.template_bank_filename, bank.snr_threshold)
	if progress_report:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_xml_%s" % logname)

	return head


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, output_filename, fake_data = False, injection_filename = None, progress_report = False):
	if len(detectors) > 1:
		raise ValueError, "only 1 instrument supported yet"

	#nto1 = gst.element_factory_make("input-selector")
	#nto1.set_property("select-all", True)
	#pipeline.add(nto1)
	#pipeparts.mktriggerxmlwritersink(pipeline, nto1, output_filename)

	# FIXME:  we can't do sum-of-squares coincidence across instruments
	# because the adder will not allow streams from multiple
	# instruments to be combined because their caps won't intersect.
	# find a way to remove the instrument property from the caps of the
	# sum-of-squares streams before bringing them together in the
	# adder.  perhaps using capssetter from the bad plugins?  maybe
	# that sort of metadata should be encoded in a tag instead of the
	# stream "format"
	for instrument in detectors:
		rates = set(rate for bank in banks for rate in bank.get_rates())
		hoftdict = mkLLOIDsrc(pipeline, instrument, detectors[instrument], rates, fake_data = fake_data, injection_filename = injection_filename, progress_report = progress_report)
		for bank in banks:
			control_snksrc = mkcontrolsnksrc(pipeline, max(bank.get_rates()), progress_report = progress_report, suffix = "%s%s" % (instrument, (bank.logname and "_%s" % bank.logname or "")))
			head = mkLLOIDsingle(
				pipeline,
				hoftdict,
				instrument,
				detectors[instrument],
				bank,
				progress_report = progress_report,
				control_snksrc = control_snksrc
			)
			#pipeparts.mkqueue(pipeline, head).link(nto1)
			pipeparts.mktriggerxmlwritersink(pipeline, head, output_filename.replace(".xml", "_%s.xml" % bank.logname))


#
# LLOID Pipeline handler
#


class LLOIDHandler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ELEMENT:
			if message.structure.get_name() == "spectrum":
				psd = pipeparts.parse_spectrum_message(message)


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog ??",
		usage = "%prog [options]",
		description = "Stream-based inspiral analysis tool"
	)
	parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache in which to find paths to .gwf frame files (required).")
	parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the GPS start time of the segment to analyze (required).")
	parser.add_option("--gps-stop-time", metavar = "seconds", help = "Set the GPS stop time of the segment to analyze (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the file from which to load injections (optional).")
	parser.add_option("--instrument", metavar = "name", help = "Set the name of the instrument to analyze (required).")
	parser.add_option("--output", metavar = "filename", help = "Set the name of the output trigger file (required).")
	parser.add_option("--reference-psd", metavar = "filename", default = "/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt", help = "Set the name of the PSD file to load.")
	parser.add_option("--template-bank", metavar = "filename", action = "append", help = "Set the name of the file from which to load the template bank (required).")
	parser.add_option("--write-pipeline", metavar = "filename", help = "Write an XML description of the as-built pipeline to this file (optional).")
	parser.add_option("--fake-data", action = "store_true", help = "Use fake LIGO data.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()

	required_options = ["gps_start_time", "gps_stop_time", "output", "template_bank", "reference_psd"]
	if not options.fake_data:
		required_options += ["frame_cache"]

	missing_options = [option for option in required_options if getattr(options, option) is None]
	if missing_options:
		raise ValueError, "missing required option(s) %s" % ", ".join("--%s" % option.replace("_", "-") for option in sorted(missing_options))

	options.gps_start_time = LIGOTimeGPS(options.gps_start_time)
	options.gps_stop_time = LIGOTimeGPS(options.gps_stop_time)

	return options, filenames


#
# =============================================================================
#
#                               PSD Measurement
#
# =============================================================================
#


def measure_psd(instrument, detector, gps_start_time, gps_stop_time, rate, injection_filename = None, verbose = False):
	class PSDHandler(object):
		def __init__(self, mainloop, pipeline):
			self.mainloop = mainloop
			self.pipeline = pipeline

			bus = pipeline.get_bus()
			bus.add_signal_watch()
			bus.connect("message", self.on_message)

			self.psd = None

		def on_message(self, bus, message):
			if message.type == gst.MESSAGE_EOS:
				self.pipeline.set_state(gst.STATE_NULL)
				self.mainloop.quit()
			elif message.type == gst.MESSAGE_ERROR:
				gerr, dbgmsg = message.parse_error()
				print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
				self.pipeline.set_state(gst.STATE_NULL)
				self.mainloop.quit()
			elif message.type == gst.MESSAGE_ELEMENT:
				if message.structure.get_name() == "spectrum":
					self.psd = pipeparts.parse_spectrum_message(message)
					#xmldoc = ligolw.Document()
					#xmldoc.appendChild(ligolw.LIGO_LW())
					#xmldoc.childNodes[-1].appendChild(lalseries.build_REAL8FrequencySeries(self.psd))
					#utils.write_filename(xmldoc, "psds/psd_%d.xml.gz" % int(self.psd.epoch), gz = True, verbose = True)

	mainloop = gobject.MainLoop()

	pipeline = gst.Pipeline("psd")
	head = pipeparts.mkframesrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	if verbose:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_src_%s" % instrument)
	if injection_filename is not None:
		head = pipeparts.mkinjections(pipeline, head, injection_filename)
	pipeparts.mkfakesink(pipeline, pipeparts.mkwhiten(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % rate)))

	handler = PSDHandler(mainloop, pipeline)

	pipeline.set_state(gst.STATE_PAUSED)
	pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, gps_start_time.ns(), gst.SEEK_TYPE_SET, gps_stop_time.ns())
	pipeline.set_state(gst.STATE_PLAYING)
	mainloop.run()

	return PSDHandler.psd


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# parse command line
#


options, filenames = parse_command_line()


#
# construct pipeline metadata
#


# FIXME:  switch to XML-format PSD file when elements no longer do their
# own parsing of the file
#reference_psd = lalseries.parse_REAL8FrequencySeries(utils.load_filename(options.reference_psd, gz = (options.reference_psd or "stdin").endswith(".gz"), verbose = options.verbose))


detectors = {
	options.instrument: DetectorData(options.frame_cache, "LSC-STRAIN", reference_psd_filename = options.reference_psd)
}


banks = [
	Bank(
		template_bank_filename,
		[
			Bank.BankFragment(2048, 0.0, 1.0),
			Bank.BankFragment(512, 1.0, 5.0),
			Bank.BankFragment(256, 5.0, 13.0),
			Bank.BankFragment(128, 13.0, 29.0)
		],
		gate_threshold = 2.0,
		snr_threshold = 5.5,
		logname = "bank%d" % n
	) for n, template_bank_filename in enumerate(options.template_bank)
]


#
# measure the PSD
#


#psd = measure_psd(
#	options.instrument,
#	detectors[options.instrument],
#	options.gps_start_time,
#	options.gps_stop_time,
#	max(rate for bank in banks for rate in bank.get_rates()),
#	injection_filename = options.injections,
#	verbose = options.verbose
#)


pipeline = gst.Pipeline("lloid")
mainloop = gobject.MainLoop()

mkLLOIDmulti(
	pipeline,
	detectors = detectors,
	banks = banks,
	output_filename = options.output,
	fake_data = options.fake_data,
	injection_filename = options.injections,
	progress_report = options.verbose
)

if options.write_pipeline is not None:
	gst.xml_write_file(pipeline, file(options.write_pipeline, "w"))

handler = LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PAUSED)
pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, options.gps_start_time.ns(), gst.SEEK_TYPE_SET, options.gps_stop_time.ns())
pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
