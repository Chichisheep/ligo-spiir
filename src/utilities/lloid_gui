#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import pygtk
import gtk
import gobject
import pygst
pygst.require("0.10")
import gst


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def playback(pipeline):
	adder = gst.element_factory_make("adder")
	resampler = gst.element_factory_make("audioresample")
	conv1 = gst.element_factory_make("audioconvert")
	filter = gst.element_factory_make("capsfilter")
	filter.set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	amp = gst.element_factory_make("audioamplify")
	amp.set_property("amplification", 5e-2)
	conv2 = gst.element_factory_make("audioconvert")
	queue = gst.element_factory_make("queue")
	queue.set_property("max-size-time", 3000000000)
	sink = gst.element_factory_make("alsasink")

	pipeline.add(adder, resampler, conv1, filter, amp, conv2, queue, sink)
	gst.element_link_many(adder, resampler, conv1, filter, amp, conv2, queue, sink)

	return adder


class TemplateBankStage(object):
	def __init__(self, pipeline, sum_squares_adder_sink, sum_squares_adder_src):
		#
		# create the templatebank element, attach a tee to the orthogonal
		# SNR source pad and matrix source pad
		#

		self.templatebank = gst.element_factory_make("lal_templatebank")
		pipeline.add(self.templatebank)
		orthogonalsnrtee = gst.element_factory_make("tee")
		pipeline.add(orthogonalsnrtee)
		matrixtee = gst.element_factory_make("tee")
		pipeline.add(matrixtee)
		self.templatebank.link_pads("src", orthogonalsnrtee, "sink")
		self.templatebank.link_pads("matrix", matrixtee, "sink")

		#
		# link the templatebank's sum-of-squares source pad to the
		# sum-of-squares adder through a resampler and queue
		#

		resampler = gst.element_factory_make("audioresample")
		pipeline.add(resampler)
		self.templatebank.link_pads("sumofsquares", resampler, "sink")
		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		resampler.link(queue)
		queue.link(sum_squares_adder_sink)

		#
		# link the orthogonal SNRs and sum-of-squares into a gate, both
		# through queues
		#

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		sum_squares_adder_src.link(queue)
		self.gate = gst.element_factory_make("lal_gate")
		pipeline.add(self.gate)
		queue.link_pads("src", self.gate, "control")
		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		orthogonalsnrtee.link(queue)
		queue.link_pads("src", self.gate, "sink")

		#
		# link the template bank's matrix and the output of the gate into
		# the mixer
		#

		mixer = gst.element_factory_make("lal_matrixmixer")
		pipeline.add(mixer)
		self.gate.link_pads("src", mixer, "sink")
		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		matrixtee.link(queue)
		queue.link_pads("src", mixer, "matrix")
		snrtee = gst.element_factory_make("tee")
		pipeline.add(snrtee)
		mixer.link(snrtee)
		self.snrresampler = gst.element_factory_make("audioresample")
		pipeline.add(self.snrresampler)
		self.snrresampler.set_property("quality", 0)
		snrtee.link(self.snrresampler)

		#
		# hook the reconstruction matrix, the chifacs, the
		# orthogonal snr and the snr into a chisquare calculator
		#

		chisquare = gst.element_factory_make("lal_chisquare")
		pipeline.add(chisquare)

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		matrixtee.link(queue)
		queue.link_pads("src", chisquare, "matrix")

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		self.templatebank.link_pads("chifacs", queue, "sink")
		queue.link_pads("src", chisquare, "chifacs")

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		orthogonalsnrtee.link(queue)
		queue.link_pads("src", chisquare, "orthosnr")

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		snrtee.link(queue)
		queue.link_pads("src", chisquare, "snr")

		self.chisqresampler = gst.element_factory_make("audioresample")
		pipeline.add(self.chisqresampler)
		self.chisqresampler.set_property("quality", 0)
		chisquare.link(self.chisqresampler)

	def get_templatebank_element(self):
		return self.templatebank

	def get_snr_element(self):
		return self.snrresampler

	def get_chisquare_element(self):
		return self.chisqresampler

	def set_templatebank(self, filename):
		self.templatebank.set_property("template-bank", filename)

	def set_reference_psd(self, filename):
		self.templatebank.set_property("reference-psd", filename)

	def set_template_slice(self, start, end, total_duration):
		self.templatebank.set_property("t-start", start)
		self.templatebank.set_property("t-end", end)
		self.templatebank.set_property("t-total-duration", total_duration)

	def set_preferred_block_size(self, samples):
		self.templatebank.set_property("snr-length", samples)

	def set_sumsquares_threshold(self, threshold):
		self.gate.set_property("threshold", threshold)


class LLOID(object):
	def __init__(self, pipeline, injections = False):

		# lets store the input in ourself 
		self.pipeline = pipeline
		self.injections = injections
		self.head = None # stores the recent thing to link to
                self.tee = {}
		self.hoft = {}
		self.bank_defs = [
                        (2048,  0.00,  1.00, 29.00, 2048 * 1),
                        (512,   1.00,  5.00, 29.00,  512 * 1),
                        (256,   5.00, 13.00, 29.00,  256 * 1),
                        (128,  13.00, 29.00, 29.00,  128 * 1),
                ]
		self.templatebank = [None] * len(self.bank_defs)
		self.sample_rates = list(set([l[0] for l in self.bank_defs]))
		self.sample_rates.sort(reverse=True) # get the sample rates in desc. order
		self.base_rate = self.sample_rates[0]
	
		# frame source
		self.generate_framesrc()

		# optional injections
		self.generate_injections()

		# downsample to max template frequency, whiten and tee
		self.generate_downsampled_stream(self.base_rate)
		self.hoft[self.base_rate] = self.generate_whiten()
		self.tee[self.base_rate] = self.generate_tee()

		# downsampled streams, don't need the first one, it was a special case
                for r in self.sample_rates[1:]:	
                	tmp, self.hoft[r] = self.generate_downsampled_stream( r, src=self.hoft[self.base_rate] )
			self.tee[r] = self.generate_tee( src=self.hoft[r] )	
  
		# sum-of-squares adder
		sumsqadder, filter = self.generate_adder(self.base_rate, src=[])

		sumsqtee = self.generate_tee(src=None)

		# template bank blocks
		self.generate_banks(sumsqadder, sumsqtee)

		# snr adder, and chisquare adder
		snradder, snr_out = self.generate_adder(self.base_rate, src=[])
		snrprogress = self.generate_progress("progress_snr")

		chisqadder, chisq_out = self.generate_adder(self.base_rate, src=[])
                chisqprogress = self.generate_progress("progress_chisquare")

		self.link_banks(snradder, chisqadder)

		# XML writer

		self.triggergen = gst.element_factory_make("lal_triggergen")
		pipeline.add(self.triggergen)

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		snrprogress.link(queue)
		queue.link_pads("src", self.triggergen, "snr")

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		chisqprogress.link(queue)
		queue.link_pads("src", self.triggergen, "chisquare")

		self.xmlwriter = gst.element_factory_make("lal_triggerxmlwriter")
		pipeline.add(self.xmlwriter)
		self.xmlwriter.set_property("sync", False)
		self.xmlwriter.set_property("preroll-queue-len", 1)
		self.triggergen.link(self.xmlwriter)
 

	def set_frame_cache(self, filename):
		self.framesrc.set_property("location", filename)

	def set_channel(self, instrument, channel):
		self.framesrc.set_property("instrument", instrument)
		self.framesrc.set_property("channel-name", channel)

	def set_segment(self, startns, stopns):
		self.framesrc.set_property("start-time-gps-ns", startns)
		self.framesrc.set_property("stop-time-gps-ns", stopns)

	def set_injection_list(self, filename):
		if self.simulation is None:
			raise TypeError, "no injection node in pipeline"
		self.simulation.set_property("xml-location", filename)

	def set_reference_psd(self, filename):
		self.whiten.set_property("compensation-psd", filename)
		for templatebank in self.templatebank:
			templatebank.set_reference_psd(filename)

	def set_templatebank(self, filename):
		self.triggergen.set_property("bank-filename", filename)
		for templatebank in self.templatebank:
			templatebank.set_templatebank(filename)

	def set_sumsquares_threshold(self, threshold):
		for templatebank in self.templatebank:
			templatebank.set_sumsquares_threshold(threshold)

	def set_snr_threshold(self, threshold):
		self.triggergen.set_property("snr-thresh", threshold)

	def set_output(self, filename):
		self.xmlwriter.set_property("location", filename)

	def generate_downsampled_stream(self, rate, src = "head"):
		if src == "head": src = self.head
        	resample = gst.element_factory_make("audioresample")
	        self.pipeline.add(resample)
	        self.head.link(resample)
	        filter = gst.element_factory_make("capsfilter")
        	self.pipeline.add(filter)
	        filter.set_property("caps", gst.Caps("audio/x-raw-float, rate="+str(rate)))
        	resample.link(filter)
		self.head = filter
		return resample, filter

	def generate_tee(self, src="head"):
                if src == "head": src = self.head
                tee = gst.element_factory_make("tee")
                self.pipeline.add(tee)
                if src:
			src.link(tee)
			self.head = tee
		return tee

	def generate_framesrc(self, block_size=16384 * 8 * 16):
		# Note this should be the first element in the pipeline
                self.framesrc = gst.element_factory_make("lal_framesrc")
                self.pipeline.add(self.framesrc)
                self.framesrc.set_property("blocksize", block_size)
                self.head = gst.element_factory_make("progressreport", "progress_src")
                self.pipeline.add(self.head)
                self.framesrc.link(self.head)
		return self.head

	def generate_injections(self, src="head"):
                if src == "head": src = self.head
                if self.injections:
                        self.simulation = gst.element_factory_make("lal_simulation")
                        self.pipeline.add(self.simulation)
                        src.link(self.simulation)
                        self.head = self.simulation
			return self.head
                else:
                        self.simulation = None # self.head stays the same
			return self.head

	def generate_whiten(self, psd_mode=1, zero_pad=4, fft_length=16, average_samples=64, src="head"):
                if src == "head": src = self.head
                self.whiten = gst.element_factory_make("lal_whiten")
                self.pipeline.add(self.whiten)
                self.whiten.set_property("psd-mode", psd_mode)
                self.whiten.set_property("zero-pad", zero_pad)
                self.whiten.set_property("fft-length", fft_length)
                self.whiten.set_property("average-samples", average_samples)
                src.link(self.whiten)
		self.head = self.whiten
		return self.head

	def generate_adder(self, rate, src=[]):
                adder = gst.element_factory_make("lal_adder")
                self.pipeline.add(adder)
                adder.set_property("sync", True)
                filter = gst.element_factory_make("capsfilter")
                self.pipeline.add(filter)
                filter.set_property("caps", gst.Caps("audio/x-raw-float, rate="+str(rate)))
                adder.link(filter)
		self.head = filter
		for s in src:
			s.link(adder)
		return adder, filter

	def generate_progress(self, name, src="head"):
                if src == "head": src = self.head
		progress = gst.element_factory_make("progressreport", name)
                self.pipeline.add(progress)
                src.link(progress)
		self.head = progress
		return progress

	def generate_template_bank(self, i, bank_filename, psd_filename, start, end, dur, blocksize, threshold, src="head"):
                if src == "head": src = self.head
                self.templatebank[i] = gst.element_factory_make("lal_templatebank")
                self.pipeline.add(self.templatebank[i])
		if src: src.link(self.templatebank[i])
		orthogonalsnrtee = self.generate_tee(src=None)
		matrixtee = self.generate_tee(src=None)
                self.templatebank.link_pads("src", orthogonalsnrtee, "sink")
                self.templatebank.link_pads("matrix", matrixtee, "sink")
                self.templatebank[i].set_property("template-bank", bank_filename)
                self.templatebank[i].set_property("reference-psd", filename)
                self.templatebank[i].set_property("t-start", start)
                self.templatebank[i].set_property("t-end", end)
                self.templatebank[i].set_property("t-total-duration", dur)
                self.templatebank[i].set_property("snr-length", blocksize)
		return self.templatebank[i], orthogonalsnrtee, orthogonalsnrtee

	def generate_gate(self):
                self.gate.set_property("threshold", threshold)


	def generate_banks(self, sumsqadder, sumsqtee):
                for i, (rate, start, end, total_duration, blocksize) in enumerate(self.bank_defs):
                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        queue.set_property("max-size-time", int(end) + 1000000000)
                        self.tee[rate].link(queue)
                        self.templatebank[i] = TemplateBankStage(self.pipeline, sumsqadder, sumsqtee)
                        queue.link(self.templatebank[i].get_templatebank_element())
                        self.templatebank[i].set_template_slice(start, end, total_duration)
                        self.templatebank[i].set_preferred_block_size(blocksize)


	def link_banks(self, snradder, chisqadder):
                for templatebank in self.templatebank:
                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        templatebank.get_snr_element().link(queue)
                        queue.link(snradder)
                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        templatebank.get_chisquare_element().link(queue)
                        queue.link(chisqadder)

		


#
# =============================================================================
#
#                                     ...
#
# =============================================================================
#


class GTK_Main:
	def __init__(self):
		window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		window.set_title("LLOID GUI")
		window.set_default_size(400, 200)
		window.connect("destroy", gtk.main_quit, "WM destroy")
		vbox = gtk.VBox()
		window.add(vbox)
		self.button = gtk.Button("Start")
		self.button.connect("clicked", self.start_stop)
		vbox.add(self.button)
		window.show_all()

		self.pipeline = gst.Pipeline("lloid")
		lloid = LLOID(self.pipeline, injections = False)

		lloid.set_frame_cache("/home/channa/scratch/frames/S5/strain-L2/LLO/L-L1_RDS_C03_L2-8741/L.cache")
		lloid.set_channel("L1", "LSC-STRAIN")
		#lloid.set_segment(874100000000000000, 874120000000000000)
		lloid.set_segment(874106958000000000, 874107558000000000)
		#lloid.set_injection_list("/home/channa/cvs/lsware/gstlal/examples/bns_injections.xml")
		lloid.set_reference_psd("/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt")
		lloid.set_templatebank("/home/channa/cvs/lsware/gstlal/examples/H1-TMPLTBANK_09_1.207-874000000-2048.xml")
		lloid.set_sumsquares_threshold(2.2)
		lloid.set_snr_threshold(0.0)
		lloid.set_output("output.xml")

		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def start_stop(self, w):
		if self.button.get_label() == "Start":
			self.button.set_label("Stop")
			self.pipeline.set_state(gst.STATE_PLAYING)
		else:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")

	def on_message(self, bus, message):
		t = message.type
		if t == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
		elif t == gst.MESSAGE_ERROR:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
			err, debug = message.parse_error()
			print "Error: %s", err, debug

GTK_Main()
gtk.gdk.threads_init()
gtk.main()
