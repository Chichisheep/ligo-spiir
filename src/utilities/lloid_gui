#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import gobject
import pygst
pygst.require("0.10")
import gst
import sys


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Bank(object):
	class BankFragment(object):
		def __init__(self, rate, start, end, blocksize = None):
			self.rate = rate
			self.start = start
			self.end = end
			if blocksize is not None:
				self.blocksize = blocksize
			else:
				# 1 second
				self.blocksize = rate

	def __init__(self, template_bank_filename, bank_fragments, length, gate_threshold):
		self.template_bank_filename = template_bank_filename
		self.bank_fragments = bank_fragments
		self.filter_length = length
		self.gate_threshold = gate_threshold

	def get_rates(self):
		return tuple(sorted(set(bank_fragment.rate for bank_fragment in self.bank_fragments), reverse = True))


class Detectors(dict):
	class DetectorData(object):
		def __init__(self, frame_cache, channel, psd, snr_threshold):
			self.frame_cache = frame_cache
			self.channel = channel
			self.psd = psd
			self.snr_threshold = snr_threshold

	def __new__(cls, initializer, *args, **kwargs):
		return dict.__new__(cls, initializer)

	def __init__(self, initializer = {}, block_size = 16384 * 16 * 8):
		dict.__init__(self, initializer)
		# default block_size = 16384 samples/second * 16 seconds *
		# 8 bytes/sample
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def mkframesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("lal_framesrc")
	elem.set_property("blocksize", detectors.block_size)
	elem.set_property("location", detectors[instrument].frame_cache)
	elem.set_property("instrument", instrument)
	elem.set_property("channel-name", detectors[instrument].channel)
	pipeline.add(elem)
	return elem

def mkcapsfilter(pipeline, src, caps):
	elem = gst.element_factory_make("capsfilter")
	elem.set_property("caps", gst.Caps(caps))
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkfakesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("audiotestsrc")
	elem.set_property("timestamp-offset", detectors.start)
	elem.set_property("samplesperbuffer", detectors.block_size / 8)
	elem.set_property("num-buffers", (detectors.end - detectors.start) / 1000000000 / (detectors.block_size / 16384 / 8))
	elem.set_property("wave", 5)
	elem.set_property("volume", 1e-20)
	pipeline.add(elem)
	return mkcapsfilter(pipeline, elem, "audio/x-raw-float, width=64, rate=16384, instrument=%s, channel_name=%s, units=strain" % (instrument, detectors[instrument].channel))

def mkprogressreport(pipeline, src, name):
	elem = gst.element_factory_make("progressreport", name)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkinjections(pipeline, src, filename):
	elem = gst.element_factory_make("lal_simulation")
	elem.set_property("xml-location", filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkresample(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("audioresample")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkwhiten(pipeline, src, reference_psd_filename):
	elem = gst.element_factory_make("lal_whiten")
	elem.set_property("psd-mode", 1)
	elem.set_property("zero-pad", 0)
	elem.set_property("fft-length", 8)
	elem.set_property("average-samples", 64)
	elem.set_property("median-samples", 7)
	elem.set_property("compensation-psd", reference_psd_filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mktee(pipeline, src, pad_name = None):
	elem = gst.element_factory_make("tee")
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkqueue(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("queue")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkbank(pipeline, src, reference_psd_filename, banks, bank, control_snk, control_src):
	elem = gst.element_factory_make("lal_templatebank")
	elem.set_property("t-start", bank.start)
	elem.set_property("t-end", bank.end)
	elem.set_property("t-total-duration", banks.filter_length)
	elem.set_property("snr-length", bank.blocksize)
	elem.set_property("template-bank", banks.template_bank_filename)
	elem.set_property("reference-psd", reference_psd_filename)
	pipeline.add(elem)
	src.link(elem)

	mkqueue(pipeline, mkresample(pipeline, elem, pad_name = "sumofsquares")).link(control_snk)
	orthosnr = mktee(pipeline, elem, pad_name = "src")
	matrix = mktee(pipeline, elem, pad_name = "matrix")

	#mknxydumpsink(pipeline, mkqueue(pipeline, orthosnr), "orthosnr_%s.txt" % elem.get_name())

	gate = gst.element_factory_make("lal_gate")
	gate.set_property("threshold", banks.gate_threshold)
	pipeline.add(gate)
	mkqueue(pipeline, control_src).link_pads("src", gate, "control")
	mkqueue(pipeline, orthosnr).link(gate)

	snr = gst.element_factory_make("lal_matrixmixer")
	pipeline.add(snr)
	mkqueue(pipeline, matrix).link_pads("src", snr, "matrix")
	gate.link(snr)
	snr = mktee(pipeline, snr)

	chisq = gst.element_factory_make("lal_chisquare")
	pipeline.add(chisq)
	mkqueue(pipeline, matrix).link_pads("src", chisq, "matrix")
	mkqueue(pipeline, elem, pad_name = "chifacs").link_pads("src", chisq, "chifacs")
	mkqueue(pipeline, orthosnr).link_pads("src", chisq, "orthosnr")
	mkqueue(pipeline, snr).link_pads("src", chisq, "snr")

	return snr, chisq

def mkfakesink(pipeline, src):
	elem = gst.element_factory_make("fakesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkfilesink(pipeline, src, filename):
	elem = gst.element_factory_make("filesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	elem.set_property("buffer-mode", 2)
	elem.set_property("location", filename)
	pipeline.add(elem)
	src.link(elem)

def mknxydumpsink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_nxydump")
	if True:
		# output for hardware injection @ 874107078.149271066
		elem.set_property("start-time", 874107068000000000)
		elem.set_property("stop-time", 874107088000000000)
	elif False:
		# output for use with software injections:
		# bns_injections.xml = 874107198.405080859, impulse =
		# 874107189
		elem.set_property("start-time", 874107188000000000)
		elem.set_property("stop-time", 874107258000000000)
	else:
		# output to dump lots and lots of data (the whole cache)
		elem.set_property("start-time", 874100128000000000)
		elem.set_property("stop-time", 874120000000000000)
	pipeline.add(elem)
	src.link(elem)
	mkfilesink(pipeline, elem, filename)

def mktriggergen(pipeline, snr, chisq, template_bank_filename, snr_threshold):
	elem = gst.element_factory_make("lal_triggergen")
	elem.set_property("bank-filename", template_bank_filename)
	elem.set_property("snr-thresh", snr_threshold)
	pipeline.add(elem)
	snr.link_pads("src", elem, "snr")
	chisq.link(elem)
	return elem

def mktriggerxmlwritersink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_triggerxmlwriter")
	elem.set_property("location", filename)
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkscopesink(pipeline, src):
	elems = (
		gst.element_factory_make("lal_multiscope"),
		gst.element_factory_make("ffmpegcolorspace"),
		gst.element_factory_make("cairotimeoverlay"),
		gst.element_factory_make("autovideosink")
	)
	elems[0].set_property("trace-duration", 4.0)
	elems[0].set_property("frame-interval", 1.0 / 16)
	elems[0].set_property("average-interval", 32.0)
	elems[0].set_property("do-timestamp", False)
	pipeline.add(*elems)
	gst.element_link_many(mkqueue(pipeline, src), *elems)

def mkplaybacksink(pipeline, src):
	elems = (
		gst.element_factory_make("adder"),
		gst.element_factory_make("audioresample"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("capsfilter"),
		gst.element_factory_make("audioamplify"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("queue"),
		gst.element_factory_make("alsasink")
	)
	elems[3].set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	elems[4].set_property("amplification", 5e-2)
	elems[6].set_property("max-size-time", 3000000000)
	pipeline.add(*elems)
	gst.element_link_many(*elems)


#
# LLOID for one instrument
#


def mkLLOIDsingle(pipeline, instrument, detectors, banks, trigger_filename = None, injection_filename = None, progress_report = False, control_snk = None, control_src = None):
	head = mkframesrc(pipeline, instrument, detectors)
	if progress_report:
		head = mkprogressreport(pipeline, head, "progress_src_%s" % instrument)

	if injection_filename is not None:
		head = mkinjections(pipeline, head, injection_filename)

	rates = banks.get_rates()

	head = mkwhiten(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % rates[0]), detectors[instrument].psd)

	hoft = {rates[0]: mktee(pipeline, head)}
	for rate in rates[1:]:
		hoft[rate] = mktee(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, hoft[rates[0]]), "audio/x-raw-float, rate=%d" % rate))

	if control_snk is None:
		control_snk = gst.element_factory_make("lal_adder")
		control_snk.set_property("sync", True)
		pipeline.add(control_snk)
		control_src = mkcapsfilter(pipeline, control_snk, "audio/x-raw-float, rate=%d" % rates[-1])
		if progress_report:
			control_src = mkprogressreport(pipeline, control_src, "progress_sumsquares_%s" % instrument)
		control_src = mktee(pipeline, control_src)
		#mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_%s.txt" % instrument)

	snr = gst.element_factory_make("lal_adder")
	snr.set_property("sync", True)
	pipeline.add(snr)

	chisq = gst.element_factory_make("lal_adder")
	chisq.set_property("sync", True)
	pipeline.add(chisq)

	for bank_fragment in banks.bank_fragments:
		head = mkqueue(pipeline, hoft[bank_fragment.rate], max_size_time = int(banks.filter_length * 1.5) * 1000000000)
		bank_snr, bank_chisq = mkbank(
			pipeline,
			head,
			detectors[instrument].psd,
			banks,
			bank_fragment,
			control_snk,
			control_src
		)

		mkqueue(pipeline, mkresample(pipeline, bank_snr, quality = 0)).link(snr)
		mkqueue(pipeline, mkresample(pipeline, bank_chisq, quality = 0)).link(chisq)

	snr = mkcapsfilter(pipeline, snr, "audio/x-raw-float, rate=%d" % rates[0])
	chisq = mkcapsfilter(pipeline, chisq, "audio/x-raw-float, rate=%d" % rates[0])
	if progress_report:
		snr = mkprogressreport(pipeline, snr, "progress_snr_%s" % instrument)
		chisq = mkprogressreport(pipeline, chisq, "progress_chisquare_%s" % instrument)
	snr = mktee(pipeline, snr)
	chisq = mktee(pipeline, chisq)
	#mknxydumpsink(pipeline, mkqueue(pipeline, snr), "snr_%s.txt" % instrument)
	#mknxydumpsink(pipeline, mkqueue(pipeline, chisq), "chisquare_%s.txt" % instrument)

	if trigger_filename is not None:
		head = mktriggergen(pipeline, mkqueue(pipeline, snr), mkqueue(pipeline, chisq), banks.template_bank_filename, detectors[instrument].snr_threshold)
		if progress_report:
			head = mkprogressreport(pipeline, head, "progress_xml_%s" % instrument)
		mktriggerxmlwritersink(pipeline, head, trigger_filename)

	return snr, chisq


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, injection_filename = None, progress_report = False):
	control_snk = gst.element_factory_make("lal_adder")
	control_snk.set_property("sync", True)
	pipeline.add(control_snk)
	control_src = mkcapsfilter(pipeline, control_snk, "audio/x-raw-float, rate=%d" % rates[-1])
	if progress_report:
		control_src = mkprogressreport(pipeline, control_src, "progress_sumsquares_coinc")
	control_src = mktee(pipeline, control_src)
	#mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_coinc.txt")

	snr = {}
	chisq = {}
	for instrument in detectors.keys():
		snr[instrument], chisq[instrument] = mkLLOIDsingle(
			pipeline,
			instrument,
			detectors,
			banks,
			trigger_filename = "output_%s.xml" % instrument,
			injection_filename = injection_filename,
			progress_report = progress_report,
			control_snk = control_snk,
			control_src = control_src
		)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


class LLOIDHandler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()


gobject.threads_init()

pipeline = gst.Pipeline("lloid")
mainloop = gobject.MainLoop()

mkLLOIDsingle(
	pipeline,
	"L1",
	detectors = Detectors({
		"L1": Detectors.DetectorData("/home/channa/scratch/frames/S5/strain-L2/LLO/L-L1_RDS_C03_L2-8741/L.cache", "LSC-STRAIN", "/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt", snr_threshold = 5.5)
	}),
	banks = Bank(
		"/home/channa/cvs/lsware/gstlal/examples/H1-TMPLTBANK_09_1.207-874000000-2048.xml",
		[
			Bank.BankFragment(2048, 0.0, 1.0),
			Bank.BankFragment(512, 1.0, 5.0),
			Bank.BankFragment(256, 5.0, 13.0),
			Bank.BankFragment(128, 13.0, 29.0)
		],
		length = 29.0,
		gate_threshold = 2.0
	),
	trigger_filename = "output.xml",
	#injection_filename = "/home/channa/cvs/lsware/gstlal/examples/bns_injections.xml",
	progress_report = True
)

handler = LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PAUSED)
pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, 874106000000000000, gst.SEEK_TYPE_SET, 874120000000000000)
pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
