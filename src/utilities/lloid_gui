#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import pygtk
import gtk
import gobject
import pygst
pygst.require("0.10")
import gst


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Banks(list):
	class Bank(object):
		def __init__(self, rate, start, end, length, blocksize = None, gate_threshold = 5.0):
			self.filt_length = length
			self.rate = rate
			self.start = start
			self.end = end
			if blocksize is not None:
				self.blocksize = blocksize
			else:
				self.blocksize = rate
			self.gate_threshold = gate_threshold

	def get_rates(self):
		return tuple(sorted(set(bank.rate for bank in self), reverse = True))

	def max_rate(self):
		return max(bank.rate for bank in self)


class Detectors(dict):
	class DetectorData(object):
		def __init__(self, frame_cache, channel, psd, template_bank_file_name, snr_threshold, injection_file = None):
			self.frame_cache = frame_cache
			self.channel = channel
			self.psd = psd
			self.template_bank_file_name = template_bank_file_name
			self.snr_threshold = snr_threshold
			self.injection_file = injection_file

	def __new__(cls, initializer, *args, **kwargs):
		return dict.__new__(cls, initializer)

	def __init__(self, initializer = {}, start = None, end = None, block_size = 16384 * 16 * 8):
		dict.__init__(self, initializer)
		self.start = start
		self.end = end
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def mkframesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("lal_framesrc")
	elem.set_property("blocksize", detectors.block_size)
	elem.set_property("location", detectors[instrument].frame_cache)
	elem.set_property("instrument", instrument)
	elem.set_property("channel-name", detectors[instrument].channel)
	elem.set_property("start-time-gps-ns", detectors.start)
	elem.set_property("stop-time-gps-ns", detectors.end)
	pipeline.add(elem)
	return elem

def mkcapsfilter(pipeline, src, caps):
	elem = gst.element_factory_make("capsfilter")
	elem.set_property("caps", gst.Caps(caps))
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkfakesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("audiotestsrc")
	elem.set_property("timestamp-offset", detectors.start)
	elem.set_property("samplesperbuffer", detectors.block_size / 8)
	elem.set_property("num-buffers", (detectors.end - detectors.start) / 1000000000 / (detectors.block_size / 16384 / 8))
	elem.set_property("wave", 5)
	elem.set_property("volume", 1e-20)
	pipeline.add(elem)
	return mkcapsfilter(pipeline, elem, "audio/x-raw-float, width=64, rate=16384, instrument=%s, channel_name=%s, units=strain" % (instrument, detectors[instrument].channel))

def mkprogressreport(pipeline, src, name):
	elem = gst.element_factory_make("progressreport", name)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkinjections(pipeline, src, filename):
	elem = gst.element_factory_make("lal_simulation")
	elem.set_property("xml-location", filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkresample(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("audioresample")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkwhiten(pipeline, src, reference_psd_filename):
	elem = gst.element_factory_make("lal_whiten")
	elem.set_property("psd-mode", 1)
	elem.set_property("zero-pad", 0)
	elem.set_property("fft-length", 8)
	elem.set_property("average-samples", 16)
	elem.set_property("compensation-psd", reference_psd_filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mktee(pipeline, src, pad_name = None):
	elem = gst.element_factory_make("tee")
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkqueue(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("queue")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkbank(pipeline, src, detectordata, bank, control_snk, control_src):
	elem = gst.element_factory_make("lal_templatebank")
	elem.set_property("t-start", bank.start)
	elem.set_property("t-end", bank.end)
	elem.set_property("t-total-duration", bank.filt_length)
	elem.set_property("snr-length", bank.blocksize)
	elem.set_property("template-bank", detectordata.template_bank_file_name)
	elem.set_property("reference-psd", detectordata.psd)
	pipeline.add(elem)
	src.link(elem)

	mkqueue(pipeline, mkresample(pipeline, elem, pad_name = "sumofsquares")).link(control_snk)
	orthosnr = mktee(pipeline, elem, pad_name = "src")
	matrix = mktee(pipeline, elem, pad_name = "matrix")

	gate = gst.element_factory_make("lal_gate")
	gate.set_property("threshold", bank.gate_threshold)
	pipeline.add(gate)
	mkqueue(pipeline, control_src).link_pads("src", gate, "control")
	mkqueue(pipeline, orthosnr).link(gate)

	snr = gst.element_factory_make("lal_matrixmixer")
	pipeline.add(snr)
	mkqueue(pipeline, matrix).link_pads("src", snr, "matrix")
	gate.link(snr)
	snr = mktee(pipeline, snr)

	chisq = gst.element_factory_make("lal_chisquare")
	pipeline.add(chisq)
	mkqueue(pipeline, matrix).link_pads("src", chisq, "matrix")
	mkqueue(pipeline, elem, pad_name = "chifacs").link_pads("src", chisq, "chifacs")
	mkqueue(pipeline, orthosnr).link_pads("src", chisq, "orthosnr")
	mkqueue(pipeline, snr).link_pads("src", chisq, "snr")

	return snr, chisq

def mkfakesink(pipeline, src, pad_name = None):
	src = mkqueue(pipeline, src, pad_name = pad_name)
	elem = gst.element_factory_make("fakesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkfilesink(pipeline, src, filename):
	elem = gst.element_factory_make("filesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	elem.set_property("buffer-mode", 2)
	elem.set_property("location", filename)
	pipeline.add(elem)
	src.link(elem)

def mknxydumpsink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_nxydump")
	if True:
		# output for hardware injection @ 874107078.149271066
		elem.set_property("start-time", 874107068000000000)
		elem.set_property("stop-time", 874107088000000000)
	elif False:
		# output for use with software injections:
		# bns_injections.xml = 874107198.405080859, impulse =
		# 874107189
		elem.set_property("start-time", 874107188000000000)
		elem.set_property("stop-time", 874107258000000000)
	else:
		# output to dump lots and lots of data (the whole cache)
		elem.set_property("start-time", 874100128000000000)
		elem.set_property("stop-time", 874120000000000000)
	pipeline.add(elem)
	src.link(elem)
	mkfilesink(pipeline, elem, filename)

def mktriggergen(pipeline, snr, chisq, detectordata):
	elem = gst.element_factory_make("lal_triggergen")
	elem.set_property("bank-filename", detectordata.template_bank_file_name)
	elem.set_property("snr-thresh", detectordata.snr_threshold)
	pipeline.add(elem)
	snr.link_pads("src", elem, "snr")
	chisq.link(elem)
	return elem

def mktriggerxmlwritersink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_triggerxmlwriter")
	elem.set_property("location", filename)
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkplaybacksink(pipeline, src):
	adder = gst.element_factory_make("adder")
	resampler = gst.element_factory_make("audioresample")
	conv1 = gst.element_factory_make("audioconvert")
	filter = gst.element_factory_make("capsfilter")
	filter.set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	amp = gst.element_factory_make("audioamplify")
	amp.set_property("amplification", 5e-2)
	conv2 = gst.element_factory_make("audioconvert")
	queue = gst.element_factory_make("queue")
	queue.set_property("max-size-time", 3000000000)
	sink = gst.element_factory_make("alsasink")
	pipeline.add(adder, resampler, conv1, filter, amp, conv2, queue, sink)
	gst.element_link_many(src, adder, resampler, conv1, filter, amp, conv2, queue, sink)


#
# LLOID for one instrument
#


def mkLLOIDSingle(pipeline, instrument, detectors, banks, trigger_filename = "output.xml", do_injections = False, progress_report = False, control_snk = None, control_src = None):
	# FIXME:  switch to mkframesrc()
	head = mkfakesrc(pipeline, instrument, detectors)
	if progress_report:
		head = mkprogressreport(pipeline, head, "progress_src_%s" % instrument)

	if do_injections:
		if detectors[instrument].injection_file is None:
			# pygst segfaults if None is used for a
			# string value
			raise ValueError, "%s injection file is %s" % (instrument, repr(detectors[instrument].injection_file))
		head = mkinjections(pipeline, head, detectors[instrument].injection_file)

	rates = banks.get_rates()

	head = mkcapsfilter(pipeline, mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % rates[0])
	head = mkwhiten(pipeline, head, detectors[instrument].psd)

	hoft = {rates[0]: mktee(pipeline, head)}
	for rate in rates[1:]:
		hoft[rate] = mktee(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, hoft[rates[0]]), "audio/x-raw-float, rate=%d" % rate))

	if control_snk is None:
		control_snk = gst.element_factory_make("lal_adder")
		control_snk.set_property("sync", True)
		pipeline.add(control_snk)
		control_src = mkcapsfilter(pipeline, control_snk, "audio/x-raw-float, rate=%d" % rates[-1])
		if progress_report:
			control_src = mkprogressreport(pipeline, control_src, "progress_sumsquares_%s" % instrument)
		control_src = mktee(pipeline, control_src)
		mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_%s.txt" % instrument)

	snr_adder = gst.element_factory_make("lal_adder")
	snr_adder.set_property("sync", True)
	pipeline.add(snr_adder)

	chisq_adder = gst.element_factory_make("lal_adder")
	chisq_adder.set_property("sync", True)
	pipeline.add(chisq_adder)

	for bank in banks:
		head = mkqueue(pipeline, hoft[bank.rate], max_size_time = int(max(bank.filt_length for bank in banks)) * 2 * 1000000000)
		snr, chisq = mkbank(pipeline, head, detectors[instrument], bank, control_snk, control_src)

		mkqueue(pipeline, mkresample(pipeline, snr, quality = 0)).link(snr_adder)
		mkqueue(pipeline, mkresample(pipeline, chisq, quality = 0)).link(chisq_adder)

	snr = mkcapsfilter(pipeline, snr_adder, "audio/x-raw-float, rate=%d" % rates[0])
	chisq = mkcapsfilter(pipeline, chisq_adder, "audio/x-raw-float, rate=%d" % rates[0])
	if progress_report:
		snr = mkprogressreport(pipeline, snr, "progress_snr_%s" % instrument)
		chisq = mkprogressreport(pipeline, chisq, "progress_chisquare_%s" % instrument)
	snr = mktee(pipeline, snr)
	chisq = mktee(pipeline, chisq)
	#mknxydumpsink(pipeline, mkqueue(pipeline, snr), "snr_%s.txt" % instrument)
	#mknxydumpsink(pipeline, mkqueue(pipeline, chisq), "chisquare_%s.txt" % instrument)

	if trigger_filename is not None:
		head = mktriggergen(pipeline, mkqueue(pipeline, snr), mkqueue(pipeline, chisq), detectors[instrument])
		if progress_report:
			head = mkprogressreport(pipeline, head, "progress_xml_%s" % instrument)
		mktriggerxmlwritersink(pipeline, head, trigger_filename)

	return snr, chisq


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, do_injections = False, progress_report = False):
	control_snk = gst.element_factory_make("lal_adder")
	control_snk.set_property("sync", True)
	pipeline.add(control_snk)
	control_src = mkcapsfilter(pipeline, control_snk, "audio/x-raw-float, rate=%d" % rates[-1])
	if progress_report:
		control_src = mkprogressreport(pipeline, control_src, "progress_sumsquares_coinc")
	control_src = mktee(pipeline, control_src)
	#mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_coinc.txt")

	snr = {}
	chisq = {}
	for instrument in detectors.keys():
		snr[instrument], chisq[instrument] = mkLLOIDSingle(
			pipeline,
			instrument,
			detectors,
			banks,
			trigger_filename = "output_%s.xml" % instrument,
			do_injections = do_injections,
			progress_report = progress_report,
			control_snk = control_snk,
			control_src = control_src
		)


#
# =============================================================================
#
#                                     ...
#
# =============================================================================
#


class GTK_Main:
	def __init__(self):
		window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		window.set_title("LLOID GUI")
		window.set_default_size(400, 200)
		window.connect("destroy", gtk.main_quit, "WM destroy")
		vbox = gtk.VBox()
		window.add(vbox)
		self.button = gtk.Button("Start")
		self.button.connect("clicked", self.start_stop)
		vbox.add(self.button)
		window.show_all()
		banks = Banks([
			Banks.Bank(2048, 0.0, 1.0, 29.0, gate_threshold = 3.0),
			Banks.Bank(512, 1.0, 5.0, 29.0, gate_threshold = 3.0),
			Banks.Bank(256, 5.0, 13.0, 29.0, gate_threshold = 3.0),
			Banks.Bank(128, 13.0, 29.0, 29.0, gate_threshold = 3.0)
		])
		detectors = Detectors({
			"L1": Detectors.DetectorData("/home/channa/scratch/frames/S5/strain-L2/LLO/L-L1_RDS_C03_L2-8741/L.cache", "LSC-STRAIN", "/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt", "/home/channa/cvs/lsware/gstlal/examples/H1-TMPLTBANK_09_1.207-874000000-2048.xml", snr_threshold = 6.0, injection_file = "/home/channa/cvs/lsware/gstlal/examples/bns_injections.xml")
		}, start = 874106958000000000, end = 874120000000000000)
		self.pipeline = gst.Pipeline("lloid")

		mkLLOIDSingle(self.pipeline, "L1", detectors, banks, trigger_filename = "output.xml", do_injections = False, progress_report = True)

		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def start_stop(self, w):
		if self.button.get_label() == "Start":
			self.button.set_label("Stop")
			self.pipeline.set_state(gst.STATE_PLAYING)
		else:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
		elif message.type == gst.MESSAGE_ERROR:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
			err, debug = message.parse_error()
			print "Error: %s", err, debug

GTK_Main()
gtk.gdk.threads_init()
gtk.main()
