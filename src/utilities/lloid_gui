#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import pygtk
import gtk
import gobject
import pygst
pygst.require("0.10")
import gst


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def fakesrc(pipeline, wave, vol=1e-20):
	src = gst.element_factory_make("audiotestsrc")
	src.set_property("timestamp-offset", 874106958000000000)
	src.set_property("samplesperbuffer", 16384)
	src.set_property("num-buffers", 1)
	src.set_property("wave", wave)
	src.set_property("volume", vol)
	pipeline.add(src)
	filter = gst.element_factory_make("capsfilter")
	#filter.set_property("caps", gst.Caps("audio/x-raw-float, width=64, rate=16384, instrument=L1, channel_name=LSC-STRAIN, units=strain"))
	pipeline.add(filter)
	src.link(filter)
	return filter


def playback(pipeline):
	adder = gst.element_factory_make("adder")
	resampler = gst.element_factory_make("audioresample")
	conv1 = gst.element_factory_make("audioconvert")
	filter = gst.element_factory_make("capsfilter")
	filter.set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	amp = gst.element_factory_make("audioamplify")
	amp.set_property("amplification", 5e-2)
	conv2 = gst.element_factory_make("audioconvert")
	queue = gst.element_factory_make("queue")
	queue.set_property("max-size-time", 3000000000)
	sink = gst.element_factory_make("alsasink")

	pipeline.add(adder, resampler, conv1, filter, amp, conv2, queue, sink)
	gst.element_link_many(adder, resampler, conv1, filter, amp, conv2, queue, sink)

	return adder

class Bank(object):
	def __init__(self, rate, start, end, length, blocksize = None):
		self.filt_length = length
		self.rate = rate
		self.start = start
		self.end = end
		if blocksize is not None:
			self.blocksize = blocksize
		else:
			self.blocksize = rate

class Banks(list):
	def get_rates(self):
		return tuple(sorted(set(bank.rate for bank in self), reverse = True))

	def base_rate(self):
		return max(bank.rate for bank in self)

class DetectorData(object):
	def __init__(self, start, end, block_size = 16384 * 16 * 8):
		self.instrument = {}
		self.frame_cache = {}
		self.channel = {}
		self.psd = {}
		self.template_bank_file_name = {}
		self.injection_file = {}
		self.start = start
		self.end = end
		self.block_size = block_size
	def add_detector(self, instrument, frame_cache, channel, psd, template_bank_file_name, injection_file=None):
		self.instrument[instrument] = instrument
		self.frame_cache[instrument] = frame_cache
		self.channel[instrument] = channel
		self.psd[instrument] = psd
		self.template_bank_file_name[instrument] = template_bank_file_name
		self.injection_file[instrument] = injection_file
		
class LLOID(object):
	def __init__(self, pipeline, detectors, banks, do_injections = False):
		self.banks = banks
		self.detectors = detectors
		# lets store the input in ourself 
		self.pipeline = pipeline
		self.do_injections = do_injections

		# frame source
		report = self.framesrcs()
		#fake = fakesrc(self.pipeline, 3, 0.5)
		#adder = gst.element_factory_make("lal_adder"); self.pipeline.add(adder)
		#q = self.queue()
		#fake.link(q)
		#report["L1"].link(q)
		#q.link_pads("src", adder, "sink0")
		#dump = self.nxy_dump(874106958000000000,874107558000000000, "control.txt")
		#sink = self.filesink("control.txt")
		#adder.link_pads("sink0", dump, "src")
		#fake.link(sink)
		#adder.set_property("sync", True)

		#return

		# optional injections
		simulation = self.injections(report)

		# whitened hoft	
		hoft_tees = self.whitened_hoft_tees(simulation)	

		#dump = self.nxy_dump(874106958000000000,874107558000000000, "hoft.txt")
		#hoft_tees["L1"][2048].link(dump)

		# SVD filter output (this has 4 src pads!!! "src", "sumofsquares", "chifacs", "matrix")
		orthosnrtee, matrixtee, chifacstee, sumofsquarestee = self.svd_filter_tees(hoft_tees)

		for det in sumofsquarestee.keys():
			for i, bank in enumerate(sumofsquarestee[det]):
				dump = self.nxy_dump(874106958000000000, 874107558000000000, "sumsq"+det+str(i)+".txt")
				bank.link(dump)

		#dump = self.nxy_dump(874106958000000000,874107558000000000, "sumsq.txt")
		#sumofsquarestee["L1"][0].link(dump)
	
		control_tee = self.control_tees(sumofsquarestee)

		#fake = self.fakesink()
		#sink = self.filesink("control.txt")
		dump = self.nxy_dump(874107086000000000, 874107286000000000, "control.txt")
		control_tee.link(dump)

		#control_tee2 = self.control_tees(orthosnrtee)

		#dump = self.nxy_dump(874107086000000000, 874107286000000000, "control2.txt")
		#control_tee2.link(dump)

		#control_tee.link(sink)
		

		#for k, v in matrixtee.items():
		#	for l in [matrixtee[k], orthosnrtee[k], chifacstee[k]]:#, sumofsquarestee[k]]:
		#		for elem in l:
		#			fake = self.fakesink()
		#			elem.link(fake)
		#return 
		gate_tee = self.gate_tees(orthosnrtee, control_tee)
		reconstructed_snr_tee = self.reconstructed_snr_tees(gate_tee, matrixtee)
		chisq_tee = self.chisquare_tees(orthosnrtee, matrixtee, reconstructed_snr_tee, chifacstee)

		dump = self.nxy_dump(874107086000000000, 874107286000000000, "snr0.txt")
		reconstructed_snr_tee["L1"][0].link(dump)

		added_snr_tee = self.added_snr_tees(reconstructed_snr_tee)
		added_chisq_tee = self.added_chisq_tees(chisq_tee)

		dump = self.nxy_dump(874107086000000000, 874107286000000000, "addedsnr.txt")
		added_snr_tee["L1"].link(dump)

		trigger_gen_tee = self.trigger_gen_tees(added_snr_tee, added_chisq_tee)

		self.xml_writer(trigger_gen_tee)

		return 


	def fakesink(self):
		q = self.queue()
		fake = gst.element_factory_make("fakesink")
		self.pipeline.add(fake)
		q.link(fake)
		return q

	def filesink(self,fname):
		filesink = gst.element_factory_make("filesink")
		self.pipeline.add(filesink)
		filesink.set_property("sync", False)
		filesink.set_property("buffer-mode",2)
		filesink.set_property("preroll-queue-len",1)
		filesink.set_property("location",fname)
		return filesink

	def nxy_dump(self,start, end, fname="nxydump.txt"):
		dump = gst.element_factory_make("lal_nxydump"); self.pipeline.add(dump)
		dump.set_property("start-time", start)
		dump.set_property("stop-time", end)
		fsink = self.filesink(fname)
		dump.link(fsink)
		return dump
		

	def resample(self):
		resample = gst.element_factory_make("audioresample")
		self.pipeline.add(resample)
		return resample

	def filter_caps(self, caps):
		filter = gst.element_factory_make("capsfilter")
		filter.set_property("caps", gst.caps_from_string(caps))
		self.pipeline.add(filter)
		return filter

	def queue(self):
		queue = gst.element_factory_make("queue")
		self.pipeline.add(queue)
		return queue

	def resample_to_rate(self, rate):
		queue_in = self.queue()
		resample = self.resample()
		queue_in.link(resample)
		filter = self.filter_caps("audio/x-raw-float, rate="+str(rate))
		resample.link(filter)
		queue_out = self.queue()
		filter.link(queue_out)
		return queue_in, queue_out

	def whiten(self, filename, psd_mode=1, zero_pad=4, fft_length=16, average_samples=64):
		whiten = gst.element_factory_make("lal_whiten")
		self.pipeline.add(whiten)
		whiten.set_property("psd-mode", psd_mode)
		whiten.set_property("zero-pad", zero_pad)
		whiten.set_property("fft-length", fft_length)
		whiten.set_property("average-samples", average_samples)
		#self.whiten.set_property("compensation-psd", filename)
		return whiten

	def tee(self):
		tee = gst.element_factory_make("tee")
		self.pipeline.add(tee)
		return tee

	def trigger_gen_tees(self, added_snr_tee, added_chisq_tee, snr_thresh=1.0):
		self.trigger_gen_tee = {}
		for det in added_snr_tee.keys():
			trig = gst.element_factory_make("lal_triggergen"); self.pipeline.add(trig)
			trig.set_property("bank-filename",  self.detectors.template_bank_file_name[det])
			trig.set_property("snr-thresh", snr_thresh)
			snrq = self.queue()
			chisqq = self.queue()
			added_snr_tee[det].link(snrq)
			added_chisq_tee[det].link(chisqq)
			snrq.link_pads("src", trig, "snr")
			chisqq.link_pads("src", trig, "chisquare")
			self.trigger_gen_tee[det] = self.tee()
			trig.link(self.trigger_gen_tee[det])
		return self.trigger_gen_tee


	def xml_writer(self, trigger_gen_tee, location="output.xml"):
		"""
		A sink
		"""
		for det in trigger_gen_tee.keys():
			xml = gst.element_factory_make("lal_triggerxmlwriter"); self.pipeline.add(xml)
			xml.set_property("location", location)
			xml.set_property("sync", False)
			xml.set_property("preroll-queue-len", 1)
			q = self.queue()
			q.link(xml)
			trigger_gen_tee[det].link(q)
			

	def whitened_hoft_tees(self, src):
		self.hoft_tee={}
		base_rate = self.banks.base_rate()
		for det in self.detectors.channel.keys():
			self.hoft_tee[det] = {}
			qin, qout = self.resample_to_rate(base_rate)
			src[det].link(qin)
			h = self.whiten(filename=self.detectors.psd[det])
			qout.link(h)
			self.hoft_tee[det][base_rate] = self.tee()
			h.link(self.hoft_tee[det][base_rate])
			for i, rate in enumerate(self.banks.get_rates()[1:]):
				qin, qout = self.resample_to_rate(rate)
				self.hoft_tee[det][base_rate].link(qin)
				self.hoft_tee[det][rate] = self.tee()
				qout.link(self.hoft_tee[det][rate])
		return self.hoft_tee



	def framesrcs(self, block_size=16384 * 8 * 16):
		# Note this should be the first element in the pipeline
		self.framesrc = {}
		report = {}
		for det in self.detectors.channel.keys():
			self.framesrc[det] = gst.element_factory_make("lal_framesrc")
			self.pipeline.add(self.framesrc[det])
			self.framesrc[det].set_property("blocksize", self.detectors.block_size)
			self.framesrc[det].set_property("location", self.detectors.frame_cache[det])
			self.framesrc[det].set_property("instrument", self.detectors.instrument[det])
			self.framesrc[det].set_property("channel-name", self.detectors.channel[det])
			self.framesrc[det].set_property("start-time-gps-ns", self.detectors.start)
			self.framesrc[det].set_property("stop-time-gps-ns", self.detectors.end)
			report[det] = gst.element_factory_make("progressreport", "progress_src")
			self.pipeline.add(report[det])
			self.framesrc[det].link(report[det])
		return report


	def injections(self, src):
		self.simulation = {}
		if self.do_injections:
			for det in self.detectors.channel.keys():	
				self.simulation[det] = gst.element_factory_make("lal_simulation")
				self.simulation[det].set_property("xml-location", self.detectors.injection_file[det])
				self.pipeline.add(self.simulation[det])
				src[det].link(self.simulation[det])
			return self.simulation
		return src

	def gate_tees(self, src, control_tee, thresh=0):
		gate_tee = {}
		for i, det in enumerate(src.keys()):
			gate_tee[det] = []
			for j in range(len(src[det])):
				print i, det, j
				queuesrc = self.queue()
				queuecontrol = self.queue() 
				gate = gst.element_factory_make("lal_gate"); self.pipeline.add(gate)
				gate.set_property("threshold", thresh)
				src[det][j].link(queuesrc)
				queuesrc.link_pads("src", gate, "sink")
				control_tee.link(queuecontrol)
				queuecontrol.link_pads("src", gate, "control")
				gate_tee[det].append(self.tee())
				gate.link(gate_tee[det][j])
		return gate_tee
			

	def reconstructed_snr_tees(self, gate_tee, matrixtee):
		self.snr_tee = {}
		for i, det in enumerate(gate_tee.keys()):
			self.snr_tee[det] = []
			for j in range(len(gate_tee[det])):
				queuesrc = self.queue() 
				queuematrix = self.queue()
				snr = gst.element_factory_make("lal_matrixmixer"); self.pipeline.add(snr)
				gate_tee[det][j].link(queuesrc)
				queuesrc.link(snr)
				matrixtee[det][j].link(queuematrix)
				queuematrix.link_pads("src", snr, "matrix")
 				self.snr_tee[det].append(self.tee())
				snr.link(self.snr_tee[det][j])
		return self.snr_tee
				
	def chisquare_tees(self, orthosnrtee, matrixtee, reconstructed_snr_tee, chifacstee):
		self.chisq_tees = {}
		for i, det in enumerate(reconstructed_snr_tee.keys()):
			self.chisq_tees[det] = []
			for j in range(len(reconstructed_snr_tee[det])):
				queuesnr = self.queue()
				queueorthosnr = self.queue() 
				queuechifacs = self.queue()
				queuematrix = self.queue() 
				orthosnrtee[det][j].link(queueorthosnr)
				matrixtee[det][j].link(queuematrix)
				chifacstee[det][j].link(queuechifacs)
				reconstructed_snr_tee[det][j].link(queuesnr)
				chisq = gst.element_factory_make("lal_chisquare"); self.pipeline.add(chisq)
				queuesnr.link_pads("src", chisq, "snr")
				queueorthosnr.link_pads("src", chisq, "orthosnr")
				queuechifacs.link_pads("src", chisq, "chifacs")
				queuematrix.link_pads("src", chisq, "matrix")
				self.chisq_tees[det].append(self.tee())
				chisq.link(self.chisq_tees[det][j])

		return self.chisq_tees


	def control_tees(self, src, control_rate=32):
		adder = gst.element_factory_make("lal_adder")
		self.pipeline.add(adder)
		adder.set_property("sync", True)
		for i, det in enumerate(src.keys()):
			for j in range(len(src[det])):
				qin, qout = self.resample_to_rate(control_rate)
				src[det][j].link(qin)
				qout.link(adder)
				#q = self.queue()
				#src[det][j].link(q)
				#q.link(adder)
		self.control_tee = self.tee() 
		queue = self.queue()
		adder.link(queue)
		queue.link(self.control_tee)
		return self.control_tee

	def added_snr_tees(self, reconstructed_snr_tee):
		self.added_snr_tees = {}
		for i, det in enumerate(reconstructed_snr_tee.keys()):
			adder = gst.element_factory_make("lal_adder")
			self.pipeline.add(adder)
			adder.set_property("sync", True)
			for j in range(len(reconstructed_snr_tee[det])):
				qin, qout = self.resample_to_rate(self.banks.base_rate())
				reconstructed_snr_tee[det][j].link(qin)
				qout.link_pads("src", adder, "sink"+str(j))
			self.added_snr_tees[det] = self.tee()
			adder.link(self.added_snr_tees[det])
		return self.added_snr_tees

	def added_chisq_tees(self, chisq_tee):
		self.added_chisq_tees = {}
		for i, det in enumerate(chisq_tee.keys()):
			adder = gst.element_factory_make("lal_adder")
			self.pipeline.add(adder)
			adder.set_property("sync", True)
			for j in range(len(chisq_tee[det])):
				qin, qout = self.resample_to_rate(self.banks.base_rate())
				chisq_tee[det][j].link(qin)
				qout.link_pads("src", adder, "sink"+str(j))
			self.added_chisq_tees[det] = self.tee()
			adder.link(self.added_chisq_tees[det])
		return self.added_chisq_tees

	def svd_filter_tees(self, src):
		self.svd_filter = {}
		self.orthosnrtee = {}
		self.matrixtee = {}
		self.chifacstee = {} 
		self.sumofsquarestee = {}
		for det in self.detectors.channel.keys():
			self.svd_filter[det] = []
			self.orthosnrtee[det] = []
			self.matrixtee[det] = []
			self.chifacstee[det] = []
			self.sumofsquarestee[det] = []
			for i in range(len(self.banks)):
				queue = gst.element_factory_make("queue")
				self.pipeline.add(queue)
				queue.set_property("max-size-time", int(self.banks[i].end)*10000000000 + 1000000000)
				src[det][self.banks[i].rate].link(queue)
				self.svd_filter[det].append(gst.element_factory_make("lal_templatebank"))
				self.pipeline.add(self.svd_filter[det][i])
				queue.link_pads("src", self.svd_filter[det][i], "sink")
				self.svd_filter[det][i].set_property("t-start", self.banks[i].start)
				self.svd_filter[det][i].set_property("t-end", self.banks[i].end)
				self.svd_filter[det][i].set_property("t-total-duration", self.banks[i].filt_length)
				self.svd_filter[det][i].set_property("snr-length", self.banks[i].blocksize)
				self.svd_filter[det][i].set_property("template-bank", self.detectors.template_bank_file_name[det])
				self.svd_filter[det][i].set_property("reference-psd", self.detectors.psd[det])
				self.orthosnrtee[det].append(self.tee())
				self.matrixtee[det].append(self.tee()) 
				self.chifacstee[det].append(self.tee())
				self.sumofsquarestee[det].append(self.tee())
				self.svd_filter[det][i].link_pads("src", self.orthosnrtee[det][i], "sink")
				self.svd_filter[det][i].link_pads("matrix", self.matrixtee[det][i], "sink")
				self.svd_filter[det][i].link_pads("chifacs", self.chifacstee[det][i], "sink")
				self.svd_filter[det][i].link_pads("sumofsquares", self.sumofsquarestee[det][i], "sink")

		return self.orthosnrtee, self.matrixtee, self.chifacstee, self.sumofsquarestee



#
# =============================================================================
#
#                                     ...
#
# =============================================================================
#


class GTK_Main:
	def __init__(self):
		window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		window.set_title("LLOID GUI")
		window.set_default_size(400, 200)
		window.connect("destroy", gtk.main_quit, "WM destroy")
		vbox = gtk.VBox()
		window.add(vbox)
		self.button = gtk.Button("Start")
		self.button.connect("clicked", self.start_stop)
		vbox.add(self.button)
		window.show_all()
		banks = Banks([
			Bank(2048, 0.0, 1.0, 29.0),
			Bank(512, 1.0, 5.0, 29.0),
			Bank(256, 5.0, 13.0, 29.0),
			Bank(128, 13.0, 29.0, 29.0)
		])
		detectors= DetectorData(874106958000000000, 874107558000000000)
		detectors.add_detector("L1", "/home/channa/scratch/frames/S5/strain-L2/LLO/L-L1_RDS_C03_L2-8741/L.cache", "LSC-STRAIN", "/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt", "/home/channa/cvs/lsware/gstlal/examples/H1-TMPLTBANK_09_1.207-874000000-2048.xml")
		self.pipeline = gst.Pipeline("lloid")
		lloid = LLOID(self.pipeline, detectors, banks, do_injections = False)

		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def start_stop(self, w):
		if self.button.get_label() == "Start":
			self.button.set_label("Stop")
			self.pipeline.set_state(gst.STATE_PLAYING)
		else:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
		elif message.type == gst.MESSAGE_ERROR:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
			err, debug = message.parse_error()
			print "Error: %s", err, debug

GTK_Main()
gtk.gdk.threads_init()
gtk.main()
