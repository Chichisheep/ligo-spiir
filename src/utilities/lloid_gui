#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
from optparse import OptionParser
import sys


import gobject
import pygst
pygst.require("0.10")
import gst


from pylal.date import LIGOTimeGPS


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Bank(object):
	class BankFragment(object):
		def __init__(self, rate, start, end, blocksize = None):
			self.rate = rate
			self.start = start
			self.end = end
			if blocksize is not None:
				self.blocksize = blocksize
			else:
				# 1 second
				self.blocksize = rate

	def __init__(self, reference_psd_filename, template_bank_filename, bank_fragments, gate_threshold):
		self.reference_psd_filename = reference_psd_filename
		self.template_bank_filename = template_bank_filename
		self.bank_fragments = bank_fragments
		self.filter_length = max(fragment.end for fragment in bank_fragments)
		self.gate_threshold = gate_threshold

	def get_rates(self):
		return set(bank_fragment.rate for bank_fragment in self.bank_fragments)


class Detectors(dict):
	class DetectorData(object):
		def __init__(self, frame_cache, channel, snr_threshold):
			self.frame_cache = frame_cache
			self.channel = channel
			self.snr_threshold = snr_threshold

	def __new__(cls, initializer, *args, **kwargs):
		return dict.__new__(cls, initializer)

	def __init__(self, initializer = {}, block_size = 16384 * 16 * 8):
		dict.__init__(self, initializer)
		# default block_size = 16384 samples/second * 16 seconds *
		# 8 bytes/sample
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def mkframesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("lal_framesrc")
	elem.set_property("blocksize", detectors.block_size)
	elem.set_property("location", detectors[instrument].frame_cache)
	elem.set_property("instrument", instrument)
	elem.set_property("channel-name", detectors[instrument].channel)
	pipeline.add(elem)
	return elem

def mkcapsfilter(pipeline, src, caps):
	elem = gst.element_factory_make("capsfilter")
	elem.set_property("caps", gst.Caps(caps))
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkfakesrc(pipeline, instrument, detectors):
	elem = gst.element_factory_make("audiotestsrc")
	elem.set_property("samplesperbuffer", detectors.block_size / 8)
	elem.set_property("wave", 5)
	elem.set_property("volume", 1e-20)
	pipeline.add(elem)
	return mkcapsfilter(pipeline, elem, "audio/x-raw-float, width=64, rate=16384, instrument=%s, channel_name=%s, units=strain" % (instrument, detectors[instrument].channel))

def mkprogressreport(pipeline, src, name):
	elem = gst.element_factory_make("progressreport", name)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkinjections(pipeline, src, filename):
	elem = gst.element_factory_make("lal_simulation")
	elem.set_property("xml-location", filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkaudioamplify(pipeline, src, amplification):
	elem = gst.element_factory_make("audioamplify")
	elem.set_property("clipping-method", 3)
	elem.set_property("amplification", amplification)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkresample(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("audioresample")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkwhiten(pipeline, src):
	elem = gst.element_factory_make("lal_whiten")
	elem.set_property("psd-mode", 1)
	elem.set_property("zero-pad", 0)
	elem.set_property("fft-length", 8)
	elem.set_property("average-samples", 64)
	elem.set_property("median-samples", 7)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mktee(pipeline, src, pad_name = None):
	elem = gst.element_factory_make("tee")
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkqueue(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("queue")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkbank(pipeline, src, banks, bank, control_snk, control_src):
	elem = gst.element_factory_make("lal_templatebank")
	elem.set_property("t-start", bank.start)
	elem.set_property("t-end", bank.end)
	elem.set_property("t-total-duration", banks.filter_length)
	elem.set_property("snr-length", bank.blocksize)
	elem.set_property("template-bank", banks.template_bank_filename)
	elem.set_property("reference-psd", banks.reference_psd_filename)
	pipeline.add(elem)
	src.link(elem)

	mkqueue(pipeline, mkresample(pipeline, elem, pad_name = "sumofsquares")).link(control_snk)
	orthosnr = mktee(pipeline, elem, pad_name = "src")
	matrix = mktee(pipeline, elem, pad_name = "matrix")

	#mknxydumpsink(pipeline, mkqueue(pipeline, orthosnr), "orthosnr_%s.txt" % elem.get_name())

	gate = gst.element_factory_make("lal_gate")
	gate.set_property("threshold", banks.gate_threshold)
	pipeline.add(gate)
	mkqueue(pipeline, control_src).link_pads("src", gate, "control")
	mkqueue(pipeline, orthosnr).link(gate)

	snr = gst.element_factory_make("lal_matrixmixer")
	pipeline.add(snr)
	mkqueue(pipeline, matrix).link_pads("src", snr, "matrix")
	gate.link(snr)
	snr = mktee(pipeline, snr)

	chisq = gst.element_factory_make("lal_chisquare")
	pipeline.add(chisq)
	mkqueue(pipeline, matrix).link_pads("src", chisq, "matrix")
	mkqueue(pipeline, elem, pad_name = "chifacs").link_pads("src", chisq, "chifacs")
	mkqueue(pipeline, orthosnr).link_pads("src", chisq, "orthosnr")
	mkqueue(pipeline, snr).link_pads("src", chisq, "snr")

	return snr, chisq

def mkfakesink(pipeline, src):
	elem = gst.element_factory_make("fakesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkfilesink(pipeline, src, filename):
	elem = gst.element_factory_make("filesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	elem.set_property("buffer-mode", 2)
	elem.set_property("location", filename)
	pipeline.add(elem)
	src.link(elem)

def mknxydumpsink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_nxydump")
	if False:
		# output for hardware injection @ 874107078.149271066
		elem.set_property("start-time", 874107068000000000)
		elem.set_property("stop-time", 874107088000000000)
	elif False:
		# output for use with software injections:
		# bns_injections.xml = 874107198.405080859, impulse =
		# 874107189
		elem.set_property("start-time", 874107188000000000)
		elem.set_property("stop-time", 874107258000000000)
	else:
		# output to dump lots and lots of data (the whole cache)
		elem.set_property("start-time", 873247860000000000)
		elem.set_property("stop-time", 873424754000000000)
	pipeline.add(elem)
	src.link(elem)
	# FIXME:  add bz2enc element from plugins-bad to compress text
	# streams.
	#src = elem
	#elem = gst.element_factory_make("bz2enc")
	#pipeline.add(elem)
	#src.link(elem)
	mkfilesink(pipeline, elem, filename)

def mktriggergen(pipeline, snr, chisq, template_bank_filename, snr_threshold):
	elem = gst.element_factory_make("lal_triggergen")
	elem.set_property("bank-filename", template_bank_filename)
	elem.set_property("snr-thresh", snr_threshold)
	pipeline.add(elem)
	snr.link_pads("src", elem, "snr")
	chisq.link(elem)
	return elem

def mktriggerxmlwritersink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_triggerxmlwriter")
	elem.set_property("location", filename)
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkscopesink(pipeline, src):
	elems = (
		gst.element_factory_make("lal_multiscope"),
		gst.element_factory_make("ffmpegcolorspace"),
		gst.element_factory_make("cairotimeoverlay"),
		gst.element_factory_make("autovideosink")
	)
	elems[0].set_property("trace-duration", 4.0)
	elems[0].set_property("frame-interval", 1.0 / 16)
	elems[0].set_property("average-interval", 32.0)
	elems[0].set_property("do-timestamp", False)
	pipeline.add(*elems)
	gst.element_link_many(mkqueue(pipeline, src), *elems)

def mkplaybacksink(pipeline, src):
	elems = (
		gst.element_factory_make("adder"),
		gst.element_factory_make("audioresample"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("capsfilter"),
		gst.element_factory_make("audioamplify"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("queue"),
		gst.element_factory_make("alsasink")
	)
	elems[3].set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	elems[4].set_property("amplification", 5e-2)
	elems[6].set_property("max-size-time", 3000000000)
	pipeline.add(*elems)
	gst.element_link_many(*elems)


#
# LLOID for one instrument
#


def mkcontrolsnksrc(pipeline, rate, progress_report = False, suffix = None):
	snk = gst.element_factory_make("lal_adder")
	snk.set_property("sync", True)
	pipeline.add(snk)
	src = mkcapsfilter(pipeline, snk, "audio/x-raw-float, rate=%d" % rate)
	if progress_report:
		src = mkprogressreport(pipeline, src, "progress_sumsquares%s" % (suffix and "_%s" % suffix or ""))
	src = mktee(pipeline, src)
	return snk, src


def mkLLOIDsingle(pipeline, instrument, detectors, banks, injection_filename = None, progress_report = False, control_snksrc = None):
	head = mkframesrc(pipeline, instrument, detectors)
	if progress_report:
		head = mkprogressreport(pipeline, head, "progress_src_%s" % instrument)

	if injection_filename is not None:
		head = mkinjections(pipeline, head, injection_filename)

	rates = sorted(set(rate for bank in banks for rate in bank.get_rates()), reverse = True)

	head = mkwhiten(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % rates[0]))

	hoft = {rates[0]: mktee(pipeline, head)}
	for rate in rates[1:]:
		hoft[rate] = mktee(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, mkaudioamplify(pipeline, hoft[rates[0]], math.sqrt(float(rates[0]) / rate))), "audio/x-raw-float, rate=%d" % rate))

	if control_snksrc is None:
		control_snksrc = mkcontrolsnksrc(pipeline, rates[-1], progress_report = progress_report, suffix = instrument)
		#mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_%s.txt" % instrument)

	for bank_number, bank in enumerate(banks):
		snr = gst.element_factory_make("lal_adder")
		snr.set_property("sync", True)
		pipeline.add(snr)

		chisq = gst.element_factory_make("lal_adder")
		chisq.set_property("sync", True)
		pipeline.add(chisq)

		for bank_fragment in bank.bank_fragments:
			head = mkqueue(pipeline, hoft[bank_fragment.rate], max_size_time = int(bank.filter_length) * 1000000000)
			bank_snr, bank_chisq = mkbank(
				pipeline,
				head,
				bank,
				bank_fragment,
				control_snksrc[0],
				control_snksrc[1]
			)
			mkqueue(pipeline, mkresample(pipeline, bank_snr, quality = 0)).link(snr)
			mkqueue(pipeline, mkresample(pipeline, bank_chisq, quality = 0)).link(chisq)

		snr = mkcapsfilter(pipeline, snr, "audio/x-raw-float, rate=%d" % rates[0])
		chisq = mkcapsfilter(pipeline, chisq, "audio/x-raw-float, rate=%d" % rates[0])
		if progress_report:
			snr = mkprogressreport(pipeline, snr, "progress_snr_%s_%d" % (instrument, bank_number))
			chisq = mkprogressreport(pipeline, chisq, "progress_chisquare_%s_%d" % (instrument, bank_number))

		#snr = mktee(pipeline, snr)
		#mknxydumpsink(pipeline, mkqueue(pipeline, snr), "snr_%s_%d.txt" % (instrument, bank_number))
		#chisq = mktee(pipeline, chisq)
		#mknxydumpsink(pipeline, mkqueue(pipeline, chisq), "chisquare_%s_%d.txt" % (instrument, bank_number))

		head = mktriggergen(pipeline, snr, chisq, bank.template_bank_filename, detectors[instrument].snr_threshold)
		if progress_report:
			head = mkprogressreport(pipeline, head, "progress_xml_%s_%d" % (instrument, bank_number))

		yield head


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, trigger_filename, injection_filename = None, progress_report = False):
	control_snksrc = mkcontrolsnksrc(pipeline, min(min(bank.get_rates()) for bank in banks), progress_report = progress_report)
	#mknxydumpsink(pipeline, mkqueue(pipeline, control_src), "sumsquares_coinc.txt")
	if len(banks) > 1:
		raise ValueError, "only 1 bank supported yet"

	for instrument in detectors.keys():
		for head in mkLLOIDsingle(
			pipeline,
			instrument,
			detectors,
			banks,
			injection_filename = injection_filename,
			progress_report = progress_report,
			control_snksrc = control_snksrc
		):
			# FIXME:  write all triggers to the same file using
			# "input-selector" element from plugins-bad.
			mktriggerxmlwritersink(pipeline, head, trigger_filename)


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog ??",
		usage = "%prog [options]",
		description = "Stream-based inspiral analysis tool"
	)
	parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache in which to find paths to .gwf frame files (required).")
	parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the GPS start time of the segment to analyze (required).")
	parser.add_option("--gps-stop-time", metavar = "seconds", help = "Set the GPS stop time of the segment to analyze (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the file from which to load injections (optional).")
	parser.add_option("--instrument", metavar = "name", help = "Set the name of the instrument to analyze (required).")
	parser.add_option("--output-prefix", metavar = "filename", help = "Set the start of the name of the output trigger file(s) (required).")
	parser.add_option("--template-bank", metavar = "filename", help = "Set the name of the file from which to load the template bank (required).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()

	missing_options = [option for option in ("frame_cache", "gps_start_time", "gps_stop_time", "output_prefix", "template_bank") if getattr(options, option) is None]
	if missing_options:
		raise ValueError, "missing required options %s" % ", ".join("--%s" % option.replace("_", "-") for option in sorted(missing_options))

	options.gps_start_time = LIGOTimeGPS(options.gps_start_time)
	options.gps_stop_time = LIGOTimeGPS(options.gps_stop_time)

	return options, filenames


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


class LLOIDHandler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()


options, filenames = parse_command_line()

gobject.threads_init()

pipeline = gst.Pipeline("lloid")
mainloop = gobject.MainLoop()

mkLLOIDmulti(
	pipeline,
	detectors = Detectors({
		options.instrument: Detectors.DetectorData(options.frame_cache, "LSC-STRAIN", snr_threshold = 5.5)
	}),
	banks = [Bank(
		"/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt",
		options.template_bank,
		[
			Bank.BankFragment(2048, 0.0, 1.0),
			Bank.BankFragment(512, 1.0, 5.0),
			Bank.BankFragment(256, 5.0, 13.0),
			Bank.BankFragment(128, 13.0, 29.0)
		],
		gate_threshold = 1.5 
	)],
	trigger_filename = "%s%s.xml" % (options.output_prefix, options.instrument),
	injection_filename = options.injections,
	progress_report = options.verbose
)

handler = LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PAUSED)
pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, options.gps_start_time.ns(), gst.SEEK_TYPE_SET, options.gps_stop_time.ns())
pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
