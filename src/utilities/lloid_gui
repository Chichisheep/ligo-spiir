#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
from optparse import OptionParser
import sys


import gobject
import pygst
pygst.require("0.10")
import gst


from pylal.date import LIGOTimeGPS


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Bank(object):
	class BankFragment(object):
		def __init__(self, rate, start, end, blocksize = None):
			self.rate = rate
			self.start = start
			self.end = end
			self.blocksize = blocksize
			if self.blocksize is None:
				# default = 1 second
				self.blocksize = self.rate

	def __init__(self, template_bank_filename, bank_fragments, gate_threshold, snr_threshold, logname = None):
		self.template_bank_filename = template_bank_filename
		self.bank_fragments = bank_fragments
		self.filter_length = max(fragment.end for fragment in bank_fragments)
		self.gate_threshold = gate_threshold
		self.snr_threshold = snr_threshold
		self.logname = logname

	def get_rates(self):
		return set(bank_fragment.rate for bank_fragment in self.bank_fragments)


class DetectorData(object):
	def __init__(self, frame_cache, channel, reference_psd_filename, block_size = 16384 * 16 * 8):
		self.frame_cache = frame_cache
		self.channel = channel
		self.reference_psd_filename = reference_psd_filename
		# default block_size = 16384 samples/second * 16 seconds *
		# 8 bytes/sample
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def mkframesrc(pipeline, instrument, detector):
	elem = gst.element_factory_make("lal_framesrc")
	elem.set_property("blocksize", detector.block_size)
	elem.set_property("location", detector.frame_cache)
	elem.set_property("instrument", instrument)
	elem.set_property("channel-name", detector.channel)
	pipeline.add(elem)
	return elem

def mkcapsfilter(pipeline, src, caps):
	elem = gst.element_factory_make("capsfilter")
	elem.set_property("caps", gst.Caps(caps))
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkfakesrc(pipeline, instrument, detector, volume = 1e-20):
	elem = gst.element_factory_make("audiotestsrc")
	elem.set_property("samplesperbuffer", detector.block_size / 8)
	elem.set_property("wave", 9)
	elem.set_property("volume", volume)
	pipeline.add(elem)
	return mkcapsfilter(pipeline, elem, "audio/x-raw-float, width=64, rate=16384, instrument=%s, channel_name=%s, units=strain" % (instrument, detector.channel))

def mkiirfilter(pipeline, a, b):
	elem = gst.element_factory_make("audioiirfilter")
	elem.set_property("a", a)
	elem.set_property("b", b)
	pipeline.add(elem)
	return elem

def mkfakeLIGOsrc(pipeline, instrument, detector):
	fakesrc1 = mkfakesrc(pipeline, instrument, detector, volume = 1.0)
	a1 = [1.87140685e-05, 3.74281370e-05, 1.87140685e-05]
	b1 = [1., 1.98861643, -0.98869215]
	filter1 = []
	for idx in range(14):
		filter1.append(mkiirfilter(pipeline, a1, b1))
	fakesrc1.link(filter1[0])
	for idx in range(13):
		filter1[idx].link(filter1[idx+1])
	filter1[-1] = mktee(pipeline, filter1[-1])
	scaledsrc1 = mkaudioamplify(pipeline, filter1[-1], 5.03407936516e-17)

	fakesrc2 = mkfakesrc(pipeline, instrument, detector, volume = 1.0)
	a2 = [9.17933667e-07, 1.83586733e-06, 9.17933667e-07]
	b2 = [1., 1.99728828, -0.99729195]
	filter2 = mkiirfilter(pipeline, a2, b2)
	fakesrc2.link(filter2)
	scaledsrc2 = mkaudioamplify(pipeline, filter2, 1.39238913312e-20)

	fakesrc3 = mkfakesrc(pipeline, instrument, detector, volume = 1.0)
	scaledsrc3 = mkaudioamplify(pipeline, fakesrc3, 2.16333076528e-23)

	fakesrc4 = mkfakesrc(pipeline, instrument, detector, volume = 1.0)
	a4 = [0.03780506, -0.03780506]
	b4 = [1.0, -0.9243905]
	filter4 = mkiirfilter(pipeline, a4, b4)
	fakesrc4.link(filter4)
	scaledsrc4 = mkaudioamplify(pipeline, filter4, 1.61077910675e-20)

	noiseadder = gst.element_factory_make("adder")
	pipeline.add(noiseadder)
	scaledsrc1.link(noiseadder)
	scaledsrc2.link(noiseadder)
	scaledsrc3.link(noiseadder)
	scaledsrc4.link(noiseadder)
	scaledsrc5 = mkaudioamplify(pipeline, noiseadder, 16384.**.5)
	return scaledsrc5

def mkprogressreport(pipeline, src, name):
	elem = gst.element_factory_make("progressreport", name)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkinjections(pipeline, src, filename):
	elem = gst.element_factory_make("lal_simulation")
	elem.set_property("xml-location", filename)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkaudioamplify(pipeline, src, amplification):
	elem = gst.element_factory_make("audioamplify")
	elem.set_property("clipping-method", 3)
	elem.set_property("amplification", amplification)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mkresample(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("audioresample")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkwhiten(pipeline, src):
	elem = gst.element_factory_make("lal_whiten")
	elem.set_property("psd-mode", 1)
	elem.set_property("zero-pad", 0)
	elem.set_property("fft-length", 8)
	elem.set_property("average-samples", 64)
	elem.set_property("median-samples", 7)
	pipeline.add(elem)
	src.link(elem)
	return elem

def mktee(pipeline, src, pad_name = None):
	elem = gst.element_factory_make("tee")
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkqueue(pipeline, src, pad_name = None, **properties):
	elem = gst.element_factory_make("queue")
	for name, value in properties.items():
		elem.set_property(name.replace("_", "-"), value)
	pipeline.add(elem)
	if pad_name is None:
		src.link(elem)
	else:
		src.link_pads(pad_name, elem, "sink")
	return elem

def mkbank(pipeline, src, bank, bank_fragment, reference_psd_filename, control_snk, control_src):
	elem = gst.element_factory_make("lal_templatebank")
	elem.set_property("t-start", bank_fragment.start)
	elem.set_property("t-end", bank_fragment.end)
	elem.set_property("t-total-duration", bank.filter_length)
	elem.set_property("snr-length", bank_fragment.blocksize)
	elem.set_property("template-bank", bank.template_bank_filename)
	elem.set_property("reference-psd", reference_psd_filename)
	pipeline.add(elem)
	src.link(elem)

	matrix = mktee(pipeline, elem, pad_name = "matrix")

	mkqueue(pipeline, mkresample(pipeline, elem, pad_name = "sumofsquares")).link(control_snk)

	gate = gst.element_factory_make("lal_gate")
	gate.set_property("threshold", bank.gate_threshold)
	pipeline.add(gate)
	mkqueue(pipeline, elem, pad_name = "src").link_pads("src", gate, "sink")
	mkqueue(pipeline, control_src).link_pads("src", gate, "control")
	# FIXME:  teach the collectpads object not to wait for buffers on
	# pads whose segments have not yet been reached by the input on the
	# other pads.  then this large queue buffer will not be required
	# because streaming can begin through the downstream adders without
	# waiting for input from all upstream elements.
	orthosnr = mktee(pipeline, mkqueue(pipeline, gate, pad_name = "src", max_size_buffers = 0, max_size_bytes = 0, max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000))

	#mknxydumpsink(pipeline, mkqueue(pipeline, orthosnr), "orthosnr_%s.txt" % elem.get_name())

	snr = gst.element_factory_make("lal_matrixmixer")
	pipeline.add(snr)
	mkqueue(pipeline, matrix).link_pads("src", snr, "matrix")
	mkqueue(pipeline, orthosnr).link(snr)
	snr = mktee(pipeline, snr)

	chisq = gst.element_factory_make("lal_chisquare")
	pipeline.add(chisq)
	mkqueue(pipeline, matrix).link_pads("src", chisq, "matrix")
	mkqueue(pipeline, elem, pad_name = "chifacs").link_pads("src", chisq, "chifacs")
	mkqueue(pipeline, orthosnr).link_pads("src", chisq, "orthosnr")
	mkqueue(pipeline, snr).link_pads("src", chisq, "snr")

	return mkresample(pipeline, snr, quality = 0), mkresample(pipeline, chisq, quality = 0)

def mkfakesink(pipeline, src):
	elem = gst.element_factory_make("fakesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkfilesink(pipeline, src, filename):
	elem = gst.element_factory_make("filesink")
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	elem.set_property("buffer-mode", 2)
	elem.set_property("location", filename)
	pipeline.add(elem)
	src.link(elem)

def mknxydumpsink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_nxydump")
	if False:
		# output for hardware injection @ 874107078.149271066
		elem.set_property("start-time", 874107068000000000)
		elem.set_property("stop-time", 874107088000000000)
	elif False:
		# output for use with software injections:
		# bns_injections.xml = 874107198.405080859, impulse =
		# 874107189
		elem.set_property("start-time", 874107188000000000)
		elem.set_property("stop-time", 874107258000000000)
	else:
		# output to dump lots and lots of data (the whole cache)
		elem.set_property("start-time", 873247860000000000)
		elem.set_property("stop-time", 873424754000000000)
	pipeline.add(elem)
	src.link(elem)
	# FIXME:  add bz2enc element from plugins-bad to compress text
	# streams.
	#src = elem
	#elem = gst.element_factory_make("bz2enc")
	#pipeline.add(elem)
	#src.link(elem)
	mkfilesink(pipeline, elem, filename)

def mktriggergen(pipeline, snr, chisq, template_bank_filename, snr_threshold):
	elem = gst.element_factory_make("lal_triggergen")
	elem.set_property("bank-filename", template_bank_filename)
	elem.set_property("snr-thresh", snr_threshold)
	pipeline.add(elem)
	snr.link_pads("src", elem, "snr")
	chisq.link(elem)
	return elem

def mktriggerxmlwritersink(pipeline, src, filename):
	elem = gst.element_factory_make("lal_triggerxmlwriter")
	elem.set_property("location", filename)
	elem.set_property("sync", False)
	elem.set_property("preroll-queue-len", 1)
	pipeline.add(elem)
	src.link(elem)

def mkscopesink(pipeline, src):
	elems = (
		gst.element_factory_make("lal_multiscope"),
		gst.element_factory_make("ffmpegcolorspace"),
		gst.element_factory_make("cairotimeoverlay"),
		gst.element_factory_make("autovideosink")
	)
	elems[0].set_property("trace-duration", 4.0)
	elems[0].set_property("frame-interval", 1.0 / 16)
	elems[0].set_property("average-interval", 32.0)
	elems[0].set_property("do-timestamp", False)
	pipeline.add(*elems)
	gst.element_link_many(mkqueue(pipeline, src), *elems)

def mkplaybacksink(pipeline, src):
	elems = (
		gst.element_factory_make("adder"),
		gst.element_factory_make("audioresample"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("capsfilter"),
		gst.element_factory_make("audioamplify"),
		gst.element_factory_make("audioconvert"),
		gst.element_factory_make("queue"),
		gst.element_factory_make("alsasink")
	)
	elems[3].set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	elems[4].set_property("amplification", 5e-2)
	elems[6].set_property("max-size-time", 3000000000)
	pipeline.add(*elems)
	gst.element_link_many(*elems)


#
# LLOID for one instrument
#


def mkcontrolsnksrc(pipeline, rate, progress_report = False, suffix = None):
	snk = gst.element_factory_make("lal_adder")
	snk.set_property("sync", True)
	pipeline.add(snk)
	src = mkcapsfilter(pipeline, snk, "audio/x-raw-float, rate=%d" % rate)
	if progress_report:
		src = mkprogressreport(pipeline, src, "progress_sumsquares%s" % (suffix and "_%s" % suffix or ""))
	src = mktee(pipeline, src)
	return snk, src


def mkLLOIDsingle(pipeline, instrument, detector, bank, fake_data = False, injection_filename = None, progress_report = False, control_snksrc = None):
	logname = "%s%s" % (instrument, (bank.logname and "_%s" % bank.logname or ""))

	if fake_data:
		head = mkfakeLIGOsrc(pipeline, instrument, detector)
	else:
		head = mkframesrc(pipeline, instrument, detector)
	if progress_report:
		head = mkprogressreport(pipeline, head, "progress_src_%s" % logname)

	if injection_filename is not None:
		head = mkinjections(pipeline, head, injection_filename)

	rates = bank.get_rates()

	correction = {
		128: 1.03 / 0.93,
		256: 1.03 / 0.93,
		512: 1.03 / 0.93,
		2048: 1.03 / 1.03
	}

	head = mkwhiten(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % max(rates)))

	hoft = {max(rates): mktee(pipeline, head)}
	for rate in sorted(rates)[:-1]:	# all but the highest rate
		# FIXME:  the default quality is 4, we should try setting
		# it higher (9?), but then the variance correction look-up
		# table will need to be re-measured
		hoft[rate] = mktee(pipeline, mkcapsfilter(pipeline, mkresample(pipeline, mkaudioamplify(pipeline, hoft[max(rates)], math.sqrt(correction[rate] * float(max(rates)) / rate))), "audio/x-raw-float, rate=%d" % rate))

	if control_snksrc is None:
		control_snksrc = mkcontrolsnksrc(pipeline, min(rates), progress_report = progress_report, suffix = logname)
		#mknxydumpsink(pipeline, mkqueue(pipeline, control_snksrc[1]), "sumsquares_%s.txt" % logname)

	snr = gst.element_factory_make("lal_adder")
	snr.set_property("sync", True)
	pipeline.add(snr)

	chisq = gst.element_factory_make("lal_adder")
	chisq.set_property("sync", True)
	pipeline.add(chisq)

	for bank_fragment in bank.bank_fragments:
		bank_snr, bank_chisq = mkbank(
			pipeline,
			mkqueue(pipeline, hoft[bank_fragment.rate], max_size_bytes = 0, max_size_buffers = 0, max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000),
			bank,
			bank_fragment,
			detector.reference_psd_filename,
			control_snksrc[0],
			control_snksrc[1]
		)
		mkqueue(pipeline, bank_snr).link(snr)
		mkqueue(pipeline, bank_chisq).link(chisq)

	snr = mkcapsfilter(pipeline, snr, "audio/x-raw-float, rate=%d" % max(rates))
	chisq = mkcapsfilter(pipeline, chisq, "audio/x-raw-float, rate=%d" % max(rates))
	if progress_report:
		snr = mkprogressreport(pipeline, snr, "progress_snr_%s" % logname)
		chisq = mkprogressreport(pipeline, chisq, "progress_chisq_%s" % logname)

	#snr = mktee(pipeline, snr)
	#mknxydumpsink(pipeline, mkqueue(pipeline, snr), "snr_%s.txt" % logname)
	#chisq = mktee(pipeline, chisq)
	#mknxydumpsink(pipeline, mkqueue(pipeline, chisq), "chisquare_%s.txt" % logname)

	head = mktriggergen(pipeline, snr, chisq, bank.template_bank_filename, bank.snr_threshold)
	if progress_report:
		head = mkprogressreport(pipeline, head, "progress_xml_%s" % logname)

	return head


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, trigger_filename, fake_data = False, injection_filename = None, progress_report = False):
	if len(banks) > 1:
		raise ValueError, "only 1 template bank supported yet"
	if len(detectors) > 1:
		raise ValueError, "only 1 instrument supported yet"

	#nto1 = gst.element_factory_make("input-selector")
	#nto1.set_property("select-all", True)
	#pipeline.add(nto1)
	#mktriggerxmlwritersink(pipeline, nto1, trigger_filename)

	for bank in banks:
		# FIXME:  the adder will not allow streams from multiple
		# instruments to be combined because their caps won't
		# intersect.  find a way to remove the instrument property
		# from the caps of the sum-of-squares streams before
		# bringing them together in the adder.  perhaps using
		# capssetter from the bad plugins?
		control_snksrc = mkcontrolsnksrc(pipeline, min(bank.get_rates()), progress_report = progress_report)
		#mknxydumpsink(pipeline, mkqueue(pipeline, control_snksrc[1]), "sumsquares_coinc.txt")

		for instrument in detectors:
			head = mkLLOIDsingle(
				pipeline,
				instrument,
				detectors[instrument],
				bank,
				fake_data = fake_data,
				injection_filename = injection_filename,
				progress_report = progress_report,
				control_snksrc = control_snksrc
			)
			#mkqueue(pipeline, head).link(nto1)
			mktriggerxmlwritersink(pipeline, head, trigger_filename)


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog ??",
		usage = "%prog [options]",
		description = "Stream-based inspiral analysis tool"
	)
	parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache in which to find paths to .gwf frame files (required).")
	parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the GPS start time of the segment to analyze (required).")
	parser.add_option("--gps-stop-time", metavar = "seconds", help = "Set the GPS stop time of the segment to analyze (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the file from which to load injections (optional).")
	parser.add_option("--instrument", metavar = "name", help = "Set the name of the instrument to analyze (required).")
	parser.add_option("--output", metavar = "filename", help = "Set the name of the output trigger file (required).")
	parser.add_option("--template-bank", metavar = "filename", action = "append", help = "Set the name of the file from which to load the template bank (required).")
	parser.add_option("--write-pipeline", metavar = "filename", help = "Write an XML description of the as-built pipeline to this file (optional).")
	parser.add_option("--fake-data", action = "store_true", help = "Use fake LIGO data.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()

	required_options = ["gps_start_time", "gps_stop_time", "output", "template_bank"]
	if not options.fake_data:
		required_options += ["frame_cache"]

	missing_options = [option for option in required_options if getattr(options, option) is None]
	if missing_options:
		raise ValueError, "missing required option(s) %s" % ", ".join("--%s" % option.replace("_", "-") for option in sorted(missing_options))

	options.gps_start_time = LIGOTimeGPS(options.gps_start_time)
	options.gps_stop_time = LIGOTimeGPS(options.gps_stop_time)

	return options, filenames


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


class LLOIDHandler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()


options, filenames = parse_command_line()

gobject.threads_init()

pipeline = gst.Pipeline("lloid")
mainloop = gobject.MainLoop()

mkLLOIDmulti(
	pipeline,
	detectors = {
		options.instrument: DetectorData(options.frame_cache, "LSC-STRAIN", reference_psd_filename = "/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt")
	},
	banks = [
		Bank(
			template_bank_filename,
			[
				Bank.BankFragment(2048, 0.0, 1.0),
				Bank.BankFragment(512, 1.0, 5.0),
				Bank.BankFragment(256, 5.0, 13.0),
				Bank.BankFragment(128, 13.0, 29.0)
			],
			gate_threshold = 1.5,
			snr_threshold = 5.5
		) for template_bank_filename in options.template_bank
	],
	trigger_filename = options.output,
	fake_data = options.fake_data,
	injection_filename = options.injections,
	progress_report = options.verbose
)

if options.write_pipeline is not None:
	gst.xml_write_file(pipeline, file(options.write_pipeline, "w"))

handler = LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PAUSED)
pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, options.gps_start_time.ns(), gst.SEEK_TYPE_SET, options.gps_stop_time.ns())
pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
