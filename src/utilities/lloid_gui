#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import numpy
from optparse import OptionParser
import sys


import gobject
import pygst
pygst.require("0.10")
import gst


gobject.threads_init()


from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import series as lalseries
from pylal.datatypes import LALUnit
from pylal.datatypes import LIGOTimeGPS
from pylal.datatypes import REAL8FrequencySeries


from gstlal import pipeio
from gstlal import pipeparts
from gstlal import cbc_template_fir


#
# =============================================================================
#
#                              Pipeline Metadata
#
# =============================================================================
#


class Bank(object):
	class BankFragment(object):
		def __init__(self, rate, start, end):
			self.rate = rate
			self.start = start
			self.end = end

		def set_template_bank(self, template_bank, tolerance, verbose = False):
			if verbose:
				print >>sys.stderr, "\t%d templates of %d samples" % template_bank.shape

			self.orthogonal_template_bank, self.singular_values, self.mix_matrix, self.chifacs = cbc_template_fir.decompose_templates(template_bank, tolerance)

			self.sum_of_squares_weights = self.singular_values * math.sqrt(self.chifacs.mean() / numpy.dot(self.singular_values, self.singular_values))

			if verbose:
				print >>sys.stderr, "\tidentified %d components" % self.orthogonal_template_bank.shape[0]
				print >>sys.stderr, "\tsum-of-squares expectation value is %g" % self.chifacs.mean()

	def __init__(self, template_bank_filename, psd, bank_fragments, gate_threshold, snr_threshold, tolerance, flow = 40.0, autocorrelation_length = None, logname = None, verbose = False):
		self.template_bank_filename = template_bank_filename	# FIXME:  remove when not needed by trigger generator element
		self.bank_fragments = bank_fragments
		self.filter_length = max(fragment.end for fragment in bank_fragments)
		self.gate_threshold = gate_threshold
		self.snr_threshold = snr_threshold
		self.logname = logname

		sample_rate = max(bank_fragment.rate for bank_fragment in bank_fragments)

		template_bank, self.autocorrelation_bank = cbc_template_fir.generate_templates(lsctables.table.get_table(utils.load_filename(template_bank_filename, gz = (template_bank_filename or "stdin").endswith(".gz"), verbose = verbose), lsctables.SnglInspiralTable.tableName), psd, flow, sample_rate, self.filter_length, autocorrelation_length = autocorrelation_length, verbose = verbose)

		n = template_bank.shape[1]	# number of samples in template
		for i, bank_fragment in enumerate(self.bank_fragments):
			if verbose:
				print >>sys.stderr, "constructing template decomposition %d of %d:  %g s ... %g s" % (i + 1, len(bank_fragments), -bank_fragment.end, -bank_fragment.start)

			# start and end times are measured *backwards* from
			# template end;  subtract from n to convert to
			# start and end index;  end:start is the slice to
			# extract (argh!  Chad!)
			start = n - int(round(bank_fragment.start * sample_rate))
			end = n - int(round(bank_fragment.end * sample_rate))
			stride = int(round(sample_rate / bank_fragment.rate))

			# extract every stride-th sample, multiply by
			# \sqrt{stride} to maintain inner product
			# normalization
			bank_fragment.set_template_bank(template_bank[:, end:start:stride] * math.sqrt(stride), tolerance, verbose = verbose)

	def get_rates(self):
		return set(bank_fragment.rate for bank_fragment in self.bank_fragments)


class DetectorData(object):
	def __init__(self, frame_cache, channel, block_size = 16384 * 8 * 1):
		self.frame_cache = frame_cache
		self.channel = channel
		# default block_size = 16384 samples/second * 8
		# bytes/sample * 1 second
		self.block_size = block_size


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


#
# LLOID for one instrument
#


def mkcontrolsnksrc(pipeline, rate, progress_report = False, suffix = None):
	snk = gst.element_factory_make("lal_adder")
	snk.set_property("sync", True)
	pipeline.add(snk)
	src = pipeparts.mkcapsfilter(pipeline, snk, "audio/x-raw-float, rate=%d" % rate)
	if progress_report:
		src = pipeparts.mkprogressreport(pipeline, src, "progress_sumsquares%s" % (suffix and "_%s" % suffix or ""))
	src = pipeparts.mktee(pipeline, src)
	return snk, src


def mkLLOIDsrc(pipeline, instrument, detector, rates, fake_data = False, injection_filename = None, progress_report = False):
	if fake_data:
		head = pipeparts.mkfakeLIGOsrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	else:
		head = pipeparts.mkframesrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	if progress_report:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_src_%s" % instrument)

	if injection_filename is not None:
		head = pipeparts.mkinjections(pipeline, head, injection_filename)

	head = pipeparts.mkwhiten(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % max(rates)))

	correction = {
		128: 1.03 / 0.93,
		256: 1.03 / 0.93,
		512: 1.03 / 0.93,
		2048: 1.03 / 1.03
	}

	hoft = {max(rates): pipeparts.mktee(pipeline, head)}
	for rate in sorted(rates)[:-1]:	# all but the highest rate
		# FIXME:  the default quality is 4, we should try setting
		# it higher (9?), but then the variance correction look-up
		# table will need to be re-measured
		hoft[rate] = pipeparts.mktee(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, pipeparts.mkaudioamplify(pipeline, hoft[max(rates)], math.sqrt(correction[rate] * float(max(rates)) / rate))), "audio/x-raw-float, rate=%d" % rate))

	return hoft


def mkLLOIDsingle(pipeline, hoftdict, instrument, detector, bank, progress_report = False, control_snksrc = None):
	logname = "%s%s" % (instrument, (bank.logname and "_%s" % bank.logname or ""))

	if control_snksrc is None:
		control_snksrc = mkcontrolsnksrc(pipeline, max(bank.get_rates()), progress_report = progress_report, suffix = logname)
		#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, control_snksrc[1]), "sumsquares_%s.txt" % logname)

	snr = gst.element_factory_make("lal_adder")
	snr.set_property("sync", True)
	pipeline.add(snr)

	for bank_fragment in bank.bank_fragments:
		pipeparts.mkLLOIDbranch(
			pipeline,
			pipeparts.mkqueue(pipeline, hoftdict[bank_fragment.rate], max_size_bytes = 0, max_size_buffers = 0, max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000),
			bank,
			bank_fragment,
			control_snksrc[0],
			control_snksrc[1]
		).link(snr)

	#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, control_snksrc[1], max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000), "control_%s.dump" % bank.logname)

	snr = pipeparts.mktogglecomplex(pipeline, pipeparts.mkcapsfilter(pipeline, snr, "audio/x-raw-float, rate=%d" % max(bank.get_rates())))

	snr = pipeparts.mktee(pipeline, snr)
	chisq = pipeparts.mkautochisq(pipeline, pipeparts.mkqueue(pipeline, snr), autocorrelation_matrix = bank.autocorrelation_bank)

	#pipeparts.mknxydumpsink(pipeline, pipeparts.mkqueue(pipeline, snr), "snr_%s.txt" % logname)
	#pipeparts.mkogmvideosink(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkchannelgram(pipeline, pipeparts.mkqueue(pipeline, snr, max_size_time = 2 * int(math.ceil(bank.filter_length)) * 1000000000)), "video/x-raw-rgb, width=640, height=480, framerate=2/1"), "channelgram.avi", verbose = True)
	#return

	head = pipeparts.mktriggergen(pipeline, pipeparts.mkqueue(pipeline, snr), chisq, bank.template_bank_filename, bank.snr_threshold)
	if progress_report:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_xml_%s" % logname)
	return head


#
# LLOID for multiple instruments with coincidence applied at the orthogonal
# sum-of-squares stage (using an adder)
#


def mkLLOIDmulti(pipeline, detectors, banks, output_filename, fake_data = False, injection_filename = None, progress_report = False):
	if len(detectors) > 1:
		raise ValueError, "only 1 instrument supported yet"

	#nto1 = gst.element_factory_make("input-selector")
	#nto1.set_property("select-all", True)
	#pipeline.add(nto1)
	#pipeparts.mktriggerxmlwritersink(pipeline, nto1, output_filename)

	for instrument in detectors:
		rates = set(rate for bank in banks for rate in bank.get_rates())
		hoftdict = mkLLOIDsrc(pipeline, instrument, detectors[instrument], rates, fake_data = fake_data, injection_filename = injection_filename, progress_report = progress_report)
		for bank in banks:
			control_snksrc = mkcontrolsnksrc(pipeline, max(bank.get_rates()), progress_report = progress_report, suffix = "%s%s" % (instrument, (bank.logname and "_%s" % bank.logname or "")))
			head = mkLLOIDsingle(
				pipeline,
				hoftdict,
				instrument,
				detectors[instrument],
				bank,
				progress_report = progress_report,
				control_snksrc = control_snksrc
			)
			#pipeparts.mkqueue(pipeline, head).link(nto1)
			pipeparts.mktriggerxmlwritersink(pipeline, head, output_filename.replace(".xml", "_%s.xml" % bank.logname))


#
# LLOID Pipeline handler
#


class LLOIDHandler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ELEMENT:
			if message.structure.get_name() == "spectrum":
				psd = pipeio.parse_spectrum_message(message)


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog ??",
		usage = "%prog [options]",
		description = "Stream-based inspiral analysis tool"
	)
	parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache in which to find paths to .gwf frame files (required).")
	parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the GPS start time of the segment to analyze (required).")
	parser.add_option("--gps-stop-time", metavar = "seconds", help = "Set the GPS stop time of the segment to analyze (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the file from which to load injections (optional).")
	parser.add_option("--instrument", metavar = "name", help = "Set the name of the instrument to analyze (required).")
	parser.add_option("--output", metavar = "filename", help = "Set the name of the output trigger file (required).")
	parser.add_option("--reference-psd", metavar = "filename", default = "/home/kipp/Development/gstlal/examples/reference_psd.xml.gz", help = "Set the name of the PSD file to load.")
	parser.add_option("--template-bank", metavar = "filename", action = "append", help = "Set the name of the file from which to load the template bank (required).")
	parser.add_option("--write-pipeline", metavar = "filename", help = "Write an XML description of the as-built pipeline to this file (optional).")
	parser.add_option("--fake-data", action = "store_true", help = "Use fake LIGO data.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()

	required_options = ["gps_start_time", "gps_stop_time", "output", "template_bank", "reference_psd"]
	if not options.fake_data:
		required_options += ["frame_cache"]

	missing_options = [option for option in required_options if getattr(options, option) is None]
	if missing_options:
		raise ValueError, "missing required option(s) %s" % ", ".join("--%s" % option.replace("_", "-") for option in sorted(missing_options))

	options.gps_start_time = LIGOTimeGPS(options.gps_start_time)
	options.gps_stop_time = LIGOTimeGPS(options.gps_stop_time)

	return options, filenames


#
# =============================================================================
#
#                               PSD Measurement
#
# =============================================================================
#


def measure_psd(instrument, detector, gps_start_time, gps_stop_time, rate, injection_filename = None, verbose = False):
	class PSDHandler(object):
		def __init__(self, mainloop, pipeline):
			self.mainloop = mainloop
			self.pipeline = pipeline

			bus = pipeline.get_bus()
			bus.add_signal_watch()
			bus.connect("message", self.on_message)

			self.psd = None

		def on_message(self, bus, message):
			if message.type == gst.MESSAGE_EOS:
				self.pipeline.set_state(gst.STATE_NULL)
				self.mainloop.quit()
			elif message.type == gst.MESSAGE_ERROR:
				gerr, dbgmsg = message.parse_error()
				print >>sys.stderr, "error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg)
				self.pipeline.set_state(gst.STATE_NULL)
				self.mainloop.quit()
			elif message.type == gst.MESSAGE_ELEMENT:
				if message.structure.get_name() == "spectrum":
					self.psd = pipeio.parse_spectrum_message(message)
					#xmldoc = ligolw.Document()
					#xmldoc.appendChild(ligolw.LIGO_LW())
					#xmldoc.childNodes[-1].appendChild(lalseries.build_REAL8FrequencySeries(self.psd))
					#utils.write_filename(xmldoc, "psds/psd_%d.xml.gz" % int(self.psd.epoch), gz = True, verbose = True)

	mainloop = gobject.MainLoop()

	pipeline = gst.Pipeline("psd")
	head = pipeparts.mkframesrc(pipeline, instrument = instrument, blocksize = detector.block_size, location = detector.frame_cache, channel_name = detector.channel)
	if verbose:
		head = pipeparts.mkprogressreport(pipeline, head, "progress_src_%s" % instrument)
	if injection_filename is not None:
		head = pipeparts.mkinjections(pipeline, head, injection_filename)
	pipeparts.mkfakesink(pipeline, pipeparts.mkwhiten(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkresample(pipeline, head), "audio/x-raw-float, rate=%d" % rate)))

	handler = PSDHandler(mainloop, pipeline)

	pipeline.set_state(gst.STATE_PAUSED)
	pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, gps_start_time.ns(), gst.SEEK_TYPE_SET, gps_stop_time.ns())
	pipeline.set_state(gst.STATE_PLAYING)
	mainloop.run()

	return PSDHandler.psd


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# parse command line
#


options, filenames = parse_command_line()


#
# construct pipeline metadata
#


reference_psd = lalseries.parse_REAL8FrequencySeries(utils.load_filename(options.reference_psd, gz = (options.reference_psd or "stdin").endswith(".gz"), verbose = options.verbose))


detectors = {
	options.instrument: DetectorData(options.frame_cache, "LSC-STRAIN")
}


banks = [
	Bank(
		template_bank_filename,
		reference_psd,
		[
			Bank.BankFragment(2048, 0.0, 1.0),
			Bank.BankFragment(512, 1.0, 5.0),
			Bank.BankFragment(256, 5.0, 13.0),
			Bank.BankFragment(128, 13.0, 29.0)
		],
		gate_threshold = 2.0,
		snr_threshold = 5.5,
		tolerance = 0.97,
		flow = 40.0,	# Hz
		autocorrelation_length = 201,	# samples
		logname = "bank%d" % n,
		verbose = options.verbose
	) for n, template_bank_filename in enumerate(options.template_bank)
]


#
# measure the PSD
#


#psd = measure_psd(
#	options.instrument,
#	detectors[options.instrument],
#	options.gps_start_time,
#	options.gps_stop_time,
#	max(rate for bank in banks for rate in bank.get_rates()),
#	injection_filename = options.injections,
#	verbose = options.verbose
#)


pipeline = gst.Pipeline("lloid")
mainloop = gobject.MainLoop()

mkLLOIDmulti(
	pipeline,
	detectors = detectors,
	banks = banks,
	output_filename = options.output,
	fake_data = options.fake_data,
	injection_filename = options.injections,
	progress_report = options.verbose
)

if options.write_pipeline is not None:
	gst.xml_write_file(pipeline, file(options.write_pipeline, "w"))

handler = LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PAUSED)
pipeline.seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH, gst.SEEK_TYPE_SET, options.gps_start_time.ns(), gst.SEEK_TYPE_SET, options.gps_stop_time.ns())
pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
