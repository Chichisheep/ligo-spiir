#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2009  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import pygtk
import gtk
import gobject
import pygst
pygst.require("0.10")
import gst


#
# =============================================================================
#
#                              Pipeline Elements
#
# =============================================================================
#


def playback(pipeline):
	adder = gst.element_factory_make("adder")
	resampler = gst.element_factory_make("audioresample")
	conv1 = gst.element_factory_make("audioconvert")
	filter = gst.element_factory_make("capsfilter")
	filter.set_property("caps", gst.Caps("audio/x-raw-float, width=32"))
	amp = gst.element_factory_make("audioamplify")
	amp.set_property("amplification", 5e-2)
	conv2 = gst.element_factory_make("audioconvert")
	queue = gst.element_factory_make("queue")
	queue.set_property("max-size-time", 3000000000)
	sink = gst.element_factory_make("alsasink")

	pipeline.add(adder, resampler, conv1, filter, amp, conv2, queue, sink)
	gst.element_link_many(adder, resampler, conv1, filter, amp, conv2, queue, sink)

	return adder


class LLOID(object):
	def __init__(self, pipeline, injections = False):

		# lets store the input in ourself 
		self.pipeline = pipeline
		self.injections = injections
		self.head = None # stores the recent thing to link to
                self.tee = {}
		self.hoft = {}
		self.bank_defs = [
                        (2048,  0.00,  1.00, 29.00, 2048 * 1),
                        (512,   1.00,  5.00, 29.00,  512 * 1),
                        (256,   5.00, 13.00, 29.00,  256 * 1),
                        (128,  13.00, 29.00, 29.00,  128 * 1),
                ]
		self.templatebank = [None] * len(self.bank_defs)
		self.sample_rates = list(set([l[0] for l in self.bank_defs]))
		self.sample_rates.sort(reverse=True) # get the sample rates in desc. order
		self.base_rate = self.sample_rates[0]
		self.gate = [None] * len(self.bank_defs)
		self.snrresampler =[None] * len(self.bank_defs)
		self.chisqresampler = [None] * len(self.bank_defs)
	
		# frame source
		self.generate_framesrc()

		# optional injections
		self.generate_injections()

		# downsample to max template frequency, whiten and tee
		self.generate_downsampled_stream(self.base_rate)
		self.hoft[self.base_rate] = self.generate_whiten()
		self.tee[self.base_rate] = self.generate_tee()

		# downsampled streams, don't need the first one, it was a special case
                for r in self.sample_rates[1:]:	
                	tmp, self.hoft[r] = self.generate_downsampled_stream( r, src=self.hoft[self.base_rate] )
			self.tee[r] = self.generate_tee( src=self.hoft[r] )	
  
		# sum-of-squares adder
		sumsqadder, filter = self.generate_adder(self.base_rate, src=[])

		sumsqtee = self.generate_tee(src=None)

		# template bank blocks

		# snr adder, and chisquare adder
		snradder, snr_out = self.generate_adder(self.base_rate, src=[])
		snrprogress = self.generate_progress("progress_snr")

		chisqadder, chisq_out = self.generate_adder(self.base_rate, src=[])
                chisqprogress = self.generate_progress("progress_chisquare")

		self.generate_banks(sumsqadder, sumsqtee, snradder, chisqadder)

		# XML writer

		self.triggergen = gst.element_factory_make("lal_triggergen")
		pipeline.add(self.triggergen)

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		snrprogress.link(queue)
		queue.link_pads("src", self.triggergen, "snr")

		queue = gst.element_factory_make("queue")
		pipeline.add(queue)
		chisqprogress.link(queue)
		queue.link_pads("src", self.triggergen, "chisquare")

		self.xmlwriter = gst.element_factory_make("lal_triggerxmlwriter")
		pipeline.add(self.xmlwriter)
		self.xmlwriter.set_property("sync", False)
		self.xmlwriter.set_property("preroll-queue-len", 1)
		self.triggergen.link(self.xmlwriter)
 

	def set_frame_cache(self, filename):
		self.framesrc.set_property("location", filename)

	def set_channel(self, instrument, channel):
		self.framesrc.set_property("instrument", instrument)
		self.framesrc.set_property("channel-name", channel)

	def set_segment(self, startns, stopns):
		self.framesrc.set_property("start-time-gps-ns", startns)
		self.framesrc.set_property("stop-time-gps-ns", stopns)

	def set_injection_list(self, filename):
		if self.simulation is None:
			raise TypeError, "no injection node in pipeline"
		self.simulation.set_property("xml-location", filename)

	def set_reference_psd(self, filename):
		self.whiten.set_property("compensation-psd", filename)
		for templatebank in self.templatebank:
			templatebank.set_property("reference-psd", filename)

	def set_templatebank(self, filename):
		self.triggergen.set_property("bank-filename", filename)
		for templatebank in self.templatebank:
			templatebank.set_property("template-bank", filename)

	def set_sumsquares_threshold(self, threshold):
		for gate in self.gate:
			gate.set_property("threshold", threshold)


	def set_snr_threshold(self, threshold):
		self.triggergen.set_property("snr-thresh", threshold)

	def set_output(self, filename):
		self.xmlwriter.set_property("location", filename)

	def generate_downsampled_stream(self, rate, src = "head"):
		if src == "head": src = self.head
        	resample = gst.element_factory_make("audioresample")
	        self.pipeline.add(resample)
	        if src: self.head.link(resample)
	        filter = gst.element_factory_make("capsfilter")
        	self.pipeline.add(filter)
	        filter.set_property("caps", gst.Caps("audio/x-raw-float, rate="+str(rate)))
        	resample.link(filter)
		self.head = filter
		return resample, filter

	def generate_tee(self, src="head"):
                if src == "head": src = self.head
                tee = gst.element_factory_make("tee")
                self.pipeline.add(tee)
                if src:
			src.link(tee)
			self.head = tee
		return tee

	def generate_framesrc(self, block_size=16384 * 8 * 16):
		# Note this should be the first element in the pipeline
                self.framesrc = gst.element_factory_make("lal_framesrc")
                self.pipeline.add(self.framesrc)
                self.framesrc.set_property("blocksize", block_size)
                self.head = gst.element_factory_make("progressreport", "progress_src")
                self.pipeline.add(self.head)
                self.framesrc.link(self.head)
		return self.head

	def generate_injections(self, src="head"):
                if src == "head": src = self.head
                if self.injections:
                        self.simulation = gst.element_factory_make("lal_simulation")
                        self.pipeline.add(self.simulation)
                        src.link(self.simulation)
                        self.head = self.simulation
			return self.head
                else:
                        self.simulation = None # self.head stays the same
			return self.head

	def generate_whiten(self, psd_mode=1, zero_pad=4, fft_length=16, average_samples=64, src="head"):
                if src == "head": src = self.head
                self.whiten = gst.element_factory_make("lal_whiten")
                self.pipeline.add(self.whiten)
                self.whiten.set_property("psd-mode", psd_mode)
                self.whiten.set_property("zero-pad", zero_pad)
                self.whiten.set_property("fft-length", fft_length)
                self.whiten.set_property("average-samples", average_samples)
                src.link(self.whiten)
		self.head = self.whiten
		return self.head

	def generate_adder(self, rate, src=[]):
                adder = gst.element_factory_make("lal_adder")
                self.pipeline.add(adder)
                adder.set_property("sync", True)
                filter = gst.element_factory_make("capsfilter")
                self.pipeline.add(filter)
                filter.set_property("caps", gst.Caps("audio/x-raw-float, rate="+str(rate)))
                adder.link(filter)
		self.head = filter
		for s in src:
			s.link(adder)
		return adder, filter

	def generate_progress(self, name, src="head"):
                if src == "head": src = self.head
		progress = gst.element_factory_make("progressreport", name)
                self.pipeline.add(progress)
                src.link(progress)
		self.head = progress
		return progress

	def generate_template_bank(self, i, start, end, dur, blocksize, src="head"):
                if src == "head": src = self.head
                self.templatebank[i] = gst.element_factory_make("lal_templatebank")
                self.pipeline.add(self.templatebank[i])
		if src: src.link(self.templatebank[i])
		orthogonalsnrtee = self.generate_tee(src=None)
		matrixtee = self.generate_tee(src=None)
                self.templatebank[i].link_pads("src", orthogonalsnrtee, "sink")
                self.templatebank[i].link_pads("matrix", matrixtee, "sink")
                self.templatebank[i].set_property("t-start", start)
                self.templatebank[i].set_property("t-end", end)
                self.templatebank[i].set_property("t-total-duration", dur)
                self.templatebank[i].set_property("snr-length", blocksize)
		return self.templatebank[i], orthogonalsnrtee, matrixtee


        def generate_banks(self, sumsqadder, sumsqtee, snradder, chisqadder):
                for i, (rate, start, end, dur, blocksize) in enumerate(self.bank_defs):
			print i
                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        queue.set_property("max-size-time", int(end) + 1000000000)
                        self.tee[rate].link(queue)
			bank, orthotee, matrixtee = self.generate_template_bank(i, start, end, dur, blocksize, src=queue)

                	resampler = gst.element_factory_make("audioresample")
	                self.pipeline.add(resampler)
	                self.templatebank[i].link_pads("sumofsquares", resampler, "sink")
        	        queue = gst.element_factory_make("queue")
                	self.pipeline.add(queue)
                	resampler.link(queue)
                	queue.link(sumsqadder)

	                queue = gst.element_factory_make("queue")
        	        self.pipeline.add(queue)
                	sumsqtee.link(queue)
	                self.gate[i] = gst.element_factory_make("lal_gate")
        	        self.pipeline.add(self.gate[i])
                	queue.link_pads("src", self.gate[i], "control")
	                queue = gst.element_factory_make("queue")
        	        self.pipeline.add(queue)
                	orthotee.link(queue)
	                queue.link_pads("src", self.gate[i], "sink")

	                mixer = gst.element_factory_make("lal_matrixmixer")
        	        self.pipeline.add(mixer)
                	self.gate[i].link_pads("src", mixer, "sink")
	                queue = gst.element_factory_make("queue")
        	        self.pipeline.add(queue)
                	matrixtee.link(queue)
	                queue.link_pads("src", mixer, "matrix")
        	        snrtee = gst.element_factory_make("tee")
                	self.pipeline.add(snrtee)
	                mixer.link(snrtee)
        	        self.snrresampler[i] = gst.element_factory_make("audioresample")
                	self.pipeline.add(self.snrresampler[i])
	                self.snrresampler[i].set_property("quality", 0)
        	        snrtee.link(self.snrresampler[i])

		        chisquare = gst.element_factory_make("lal_chisquare")
                	self.pipeline.add(chisquare)

	                queue = gst.element_factory_make("queue")
        	        self.pipeline.add(queue)
                	matrixtee.link(queue)
	                queue.link_pads("src", chisquare, "matrix")
	
        	        queue = gst.element_factory_make("queue")
                	self.pipeline.add(queue)
	                self.templatebank[i].link_pads("chifacs", queue, "sink")
        	        queue.link_pads("src", chisquare, "chifacs")

	                queue = gst.element_factory_make("queue")
        	        self.pipeline.add(queue)
                	orthotee.link(queue)
	                queue.link_pads("src", chisquare, "orthosnr")

        	        queue = gst.element_factory_make("queue")
                	self.pipeline.add(queue)
	                snrtee.link(queue)
        	        queue.link_pads("src", chisquare, "snr")

	                self.chisqresampler[i] = gst.element_factory_make("audioresample")
        	        self.pipeline.add(self.chisqresampler[i])
                	self.chisqresampler[i].set_property("quality", 0)
	                chisquare.link(self.chisqresampler[i])

                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        self.snrresampler[i].link(queue)
                        queue.link(snradder)
                        queue = gst.element_factory_make("queue")
                        self.pipeline.add(queue)
                        self.chisqresampler[i].link(queue)
                        queue.link(chisqadder)



#
# =============================================================================
#
#                                     ...
#
# =============================================================================
#


class GTK_Main:
	def __init__(self):
		window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		window.set_title("LLOID GUI")
		window.set_default_size(400, 200)
		window.connect("destroy", gtk.main_quit, "WM destroy")
		vbox = gtk.VBox()
		window.add(vbox)
		self.button = gtk.Button("Start")
		self.button.connect("clicked", self.start_stop)
		vbox.add(self.button)
		window.show_all()

		self.pipeline = gst.Pipeline("lloid")
		lloid = LLOID(self.pipeline, injections = False)

		lloid.set_frame_cache("/home/channa/scratch/frames/S5/strain-L2/LLO/L-L1_RDS_C03_L2-8741/L.cache")
		lloid.set_channel("L1", "LSC-STRAIN")
		#lloid.set_segment(874100000000000000, 874120000000000000)
		lloid.set_segment(874106958000000000, 874107558000000000)
		#lloid.set_injection_list("/home/channa/cvs/lsware/gstlal/examples/bns_injections.xml")
		lloid.set_reference_psd("/home/channa/cvs/lsware/gstlal/examples/reference_psd.txt")
		lloid.set_templatebank("/home/channa/cvs/lsware/gstlal/examples/H1-TMPLTBANK_09_1.207-874000000-2048.xml")
		lloid.set_sumsquares_threshold(2.2)
		lloid.set_snr_threshold(0.0)
		lloid.set_output("output.xml")

		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def start_stop(self, w):
		if self.button.get_label() == "Start":
			self.button.set_label("Stop")
			self.pipeline.set_state(gst.STATE_PLAYING)
		else:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")

	def on_message(self, bus, message):
		t = message.type
		if t == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
		elif t == gst.MESSAGE_ERROR:
			self.pipeline.set_state(gst.STATE_NULL)
			self.button.set_label("Start")
			err, debug = message.parse_error()
			print "Error: %s", err, debug

GTK_Main()
gtk.gdk.threads_init()
gtk.main()
