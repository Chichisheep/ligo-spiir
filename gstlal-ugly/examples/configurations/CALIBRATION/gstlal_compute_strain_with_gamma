#!/usr/bin/env python
#
# Copyright (C) 2010, 2011  Jordi Burguet-Castell
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""\
Generate h(t).

It tries to mimic the behavior of lalapps_ComputeStrainDriver (which
uses LAL's ComputeStrain.c). It does not compute the gamma factors for
the moment.

It reads DARM_ERR and DARM_CTRL from the gwf files specified in the
cache file. The filters file has to be in numpy's npz format, and can
be generated from an old one with calfilters2npz.py (in examples/utilities).
"""
#
# ==========================================================================
#
#                              Preamble
#
# ==========================================================================
#

import os
import sys
import numpy

import gobject
gobject.threads_init()
import pygtk
pygtk.require('2.0')
import pygst
pygst.require('0.10')
import gst
from optparse import OptionParser

from gstlal import pipeparts
from gstlal import lloidparts
from gstlal import pipeutil

from glue import segments
from pylal.datatypes import LIGOTimeGPS

parser = OptionParser(
	version = '%prog 0.95',
	usage = '%prog [options]',
	description = __doc__
)
add = parser.add_option # short hand
add('--gps-start-time', metavar = 'seconds', help = 'Set the start time of the segment to analyze in GPS seconds (required).  Can be specified to nanosecond precision.')
add('--gps-end-time', metavar = 'seconds', help = 'Set the end time of the segment to analyze in GPS seconds (required).  Can be specified to nanosecond precision.')
add('--filters-file', metavar = 'filename', help = 'Name of file containing filters (in npz format) (required).')
add('--frame-cache', metavar = 'filename', help = 'Name of frame cache file (required).')
add('--ifo', metavar = '[H1|H2|L1]', help = 'Name of the interferometer (H1, H2, L1) (required).')
add('--wings', metavar = 'seconds', default = 16, help = 'Size of wings in seconds.')
add('--frame-type', metavar = 'filename', default = 'GSTLAL_CAL', help = 'Frame type to be written.')
add('--verbose', action = 'store_true', help = 'Be verbose (option).')
add('--write-pipeline', metavar = 'filename', help = 'Write a DOT graph description of the as-built pipeline to this file (optional).  The environment variable GST_DEBUG_DUMP_DOT_DIR must be set for this option to work.')

options, filenames = parser.parse_args()

required_options = ['gps_start_time', 'gps_end_time', 'filters_file', 'frame_cache', 'ifo']

missing_options = []
missing_options +=['--%s' % option.replace('_','-') for option in required_options if getattr(options, option) is None]
if missing_options:
	raise ValueError('missing required option(s) %s' % ', '.join(sorted(missing_options)))
	parser.print_help()
	print """\nExample:
	%s --gps-start-time=943009024 --gps-end-time=$((943009024+64)) --filters-file=filters.npz --frame-cache=data.cache --ifo=H1 --frame-type=H1_GSTLAL_C02""" % sys.argv[0]
	sys.exit()

filters = numpy.load(options.filters_file)

options.seg = segments.segment(LIGOTimeGPS(options.gps_start_time), LIGOTimeGPS(options.gps_end_time))
options.srate = 16384 # FIXME: must be 16384 for the high pass filters to work as set up

#
# ==========================================================================
#
#                              Handler 
#
# ==========================================================================
#

class Handler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect('message', self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
			sys.exit("error (%s.%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg))


#
# ========================================================================
#
#                                Main
#
# ========================================================================
#

if options.gps_start_time is None:
	seek_start_type = gst.SEEK_TYPE_NONE
	seek_start_time = -1 # gst.CLOCK_TIME_NONE is exported as unsigned, should have been signed
else:
	seek_start_type = gst.SEEK_TYPE_SET
	seek_start_time = options.seg[0].ns()

if options.gps_end_time is None:
	seek_stop_type = gst.SEEK_TYPE_NONE
	seek_stop_time = -1 # gst.CLOCK_TIME_NONE is exported as unsigned, should have been signed
else:
	seek_stop_type = gst.SEEK_TYPE_SET
	seek_stop_time = options.seg[1].ns()

seekevent = gst.event_new_seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH | gst.SEEK_FLAG_KEY_UNIT, seek_start_type, seek_start_time, seek_stop_type, seek_stop_time)

#
# The pipeline looks like:
#
#  derr -> 1/C               [1] \
#                                 | -> [3] save
#  dctrol -> HPx2 -> AW -> A [2] /
#

pipeline = gst.Pipeline('calibration')
mainloop = gobject.MainLoop()
handler = Handler(mainloop, pipeline)

# [1] Elements in the first path (from DARM_ERR channel)

path1 = lloidparts.mkLLOIDbasicsrc(
	pipeline,
	seekevent,
	options.ifo,
	lloidparts.DetectorData(options.frame_cache, 'LSC-DARM_ERR'),
)

path1 = pipeparts.mkreblock(pipeline, path1)
path1 = pipeparts.mkcapsfilter(pipeline, path1, 'audio/x-raw-float, width=64, rate=[%d,MAX]' % options.srate)
path1 = pipeparts.mkresample(pipeline, path1, quality = 9)
path1 = pipeparts.mkcapsfilter(pipeline, path1, 'audio/x-raw-float, width=64, rate=[%d,MAX]' % options.srate)
path1 = pipeparts.mkfirbank(pipeline, path1, fir_matrix=[filters['inv_sensing']], latency=int(-filters['inv_sens_delay']))
# the *delay* is negative (an advance), and so latency = -delay ... funny legacy

# [2] Elements in the second path (from DARM_CTRL channels)

path2 = lloidparts.mkLLOIDbasicsrc(
	pipeline,
	seekevent,
	options.ifo,
	lloidparts.DetectorData(options.frame_cache, 'LSC-DARM_CTRL'),
)

path2 = pipeparts.mkreblock(pipeline, path2)
path2 = pipeparts.mkcapsfilter(pipeline, path2, 'audio/x-raw-float, width=64, rate=[%d,MAX]' % options.srate)
path2 = pipeparts.mkresample(pipeline, path2, quality = 9)
path2 = pipeparts.mkcapsfilter(pipeline, path2, 'audio/x-raw-float, width=64, rate=[%d,MAX]' % options.srate)

hpf0 = pipeutil.mkelem('audiowsinclimit', {'mode': 1, 'cutoff': 20, 'window': 2, 'length': 2*2000+1})
# mode: 1 -> high pass filter, cutoff: 20 -> cf. ComputeStrain.c (0.00244140625 * 16384/2), window: 2 -> gaussian, length: 2*2000+1 -> 2 * N_FIR_HP + 1, cf. ComputeStrain.c
pipeline.add(hpf0)
path2.link(hpf0)

hpf1 = pipeutil.mkelem('audiowsinclimit', {'mode': 1, 'cutoff': 20, 'window': 2, 'length': 2*2000+1})
pipeline.add(hpf1)
hpf0.link(hpf1)

# FIXME: Get this to work with firbank element
path2 = pipeparts.mkfirbank(pipeline, hpf1, fir_matrix=[filters['awhitening']])
path2 = pipeparts.mkfirbank(pipeline, path2, fir_matrix=[filters['actuation']])

# [3] Elements from adder to saving the result

Fs = options.srate # sampling rate
T = int(options.gps_end_time) - int(options.gps_start_time) # original duration

adder = pipeutil.mkelem('lal_adder', {'sync': True})
pipeline.add(adder)
path1.link(adder)
path2.link(adder)

path3 = pipeparts.mktaginject(pipeline, adder, tags = 'channel-name=LDAS-STRAIN')
path3 = pipeparts.mktrim(pipeline, path3, initial_offset = Fs * options.wings, final_offset = Fs * (T - options.wings))
path3 = pipeparts.mkframesink(pipeline, path3, frame_type = options.frame_type, duration = T - 2 * options.wings)

#
# =======================================================================
#
#                           Boilerplate
#
# =======================================================================
#

def write_dump_dot(pipeline, filestem, verbose = False):
	if 'GST_DEBUG_DUMP_DOT_DIR' not in os.environ:
		raise ValueError, 'cannot write pipeline, environment variable GST_DEBUG_DUMP_DOT_DIR is not set'
	gst.DEBUG_BIN_TO_DOT_FILE(pipeline, gst.DEBUG_GRAPH_SHOW_ALL, filestem)
	if verbose:
		print >>sys.stderr, 'Wrote pipeline to %s' % os.path.join(os.environ['GST_DEBUG_DUMP_DOT_DIR'], '%s.dot' % filestem)

if options.write_pipeline is not None:
	write_dump_dot(pipeline, '%s.%s' % (options.write_pipeline, 'NULL'), verbose = options.verbose)

if options.verbose:
	print >>sys.stderr, 'setting pipeline state to paused ...'
if pipeline.set_state(gst.STATE_PAUSED) != gst.STATE_CHANGE_SUCCESS:
	raise RuntimeError, 'pipeline did not enter paused state'

if options.verbose:
	print >>sys.stderr, 'setting pipeline state to playing ...'
if pipeline.set_state(gst.STATE_PLAYING) != gst.STATE_CHANGE_SUCCESS:
	raise RuntimeError, 'pipeline did not enter playing state'

if options.write_pipeline is not None:
	write_dump_dot(pipeline, '%s.%s' % (options.write_pipeline, 'PLAYING'), verbose = options.verbose)

if options.verbose:
	print >>sys.stderr, 'running pipeline ...'
	
mainloop.run()
