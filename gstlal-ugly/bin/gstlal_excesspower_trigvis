#!/usr/bin/env python
import sys

import matplotlib
import matplotlib.gridspec
matplotlib.use("Agg")
from matplotlib import pyplot

from mpl_toolkits.axes_grid.inset_locator import inset_axes
from mpl_toolkits.axes_grid import make_axes_locatable

from scipy.stats import chi2, chi

import numpy
import math

import itertools

from glue.ligolw import utils
from glue.ligolw import lsctables
from glue import segments

from optparse import OptionParser

parser = OptionParser()
parser.add_option("-c", "--channels", action="store", help="Comma separated list of channels. Will plot triggers only from the channels indicated. Otherwise, all channels will be plotted.")
parser.add_option("-o", "--output-file", action="store", help="File to output image to. Default: trigmap.png")
parser.add_option("-i", "--instruments", action="store", help="Comma separates list of instruments. Will plot channels only from the instruments indicated. Otherwise, all no instrument selection is done.")
parser.add_option("-s", "--gps-start", action="store", type=float, help="Plot triggers only after indicated gps time. Default is to infer from triggers.")
parser.add_option("-e", "--gps-end", action="store", type=float, help="Plot triggers only before indicated gps time. Default is to infer from triggers.")
parser.add_option("-f", "--low-frequency", action="store", type=float, default=32.0, help="Plot trigggers with central frequency above this frequency. Default is 32.")
parser.add_option("-F", "--high-frequency", action="store", type=float, default=2000.0, help="Plot trigggers with central frequency below this frequency. Default is 2000.")
parser.add_option("-I", "--infer-parameters", action="store_true", help="Infer the TF map dimensions from the search details in the input files.")
parser.add_option("-S", "--snr-thresh", action="store", type=float, default=0.0, help="Plot trigggers with snr greater than that indicated.")
parser.add_option("-m", "--mark-time", action="store", type=float, help="Mark a particular time on the map. Useful for identifying triggers in a file spanning a large time.")
parser.add_option("-r", "--enable-event-hist", action="store_true", help="Enable the subplot with event rate versus strength for the channel.")
<<<<<<< Updated upstream
=======
parser.add_option("-w", "--ignore-whitener", action="store", type=float, default=20.0, help="Ignore the first N seconds of data (from whitening effects), default is 20.")
>>>>>>> Stashed changes

opts, args = parser.parse_args()

if( opts.channels is not None ):
	channels = opts.channels.split(",")
else: channels = None

if( opts.instruments is not None ):
	print instruments
else: instruments = None

# TODO: group by IFO

events = lsctables.SnglBurstTable()
for arg in args:
	xmldoc = utils.load_filename( arg )
	for tbl in lsctables.getTablesByType( xmldoc, lsctables.SnglBurstTable ):
		events += tbl 

	# search data
	#metad = lsctables.getTablesByType( xmldoc, lsctables.SearchSummaryTable )[0]

viewseg = segments.segment( segments.NegInfinity, segments.PosInfinity )
if( opts.gps_start is None ):
	viewseg = segments.segment( min([e.peak_time for e in events]), viewseg[1] )
else: viewseg = segments.segment( opts.gps_start, viewseg[1] )
if( opts.gps_end is None ):
	viewseg = segments.segment( viewseg[0], max([e.peak_time for e in events]) )
else: viewseg = segments.segment( viewseg[0], opts.gps_end )
viewseg = segments.segment( viewseg[0]+opts.ignore_whitener, viewseg[1] )

if( instruments is None and channels is None ):
	instruments = {}
	for event in events:
		instruments[event.ifo] = None
	instruments = instruments.keys()
if( instruments is None ):
	instruments = {}
	for channel in channels:
		instruments[channel.split(":")[0]] = None
	instruments = instruments.keys()

print "Examining instruments: %s" % str(instruments)

if( channels is None ):
	channels = {}
	for event in events:
		if( event.ifo in instruments ):
			channels[(event.ifo, event.channel)] = None
	channels = channels.keys()
<<<<<<< Updated upstream
	channels.sort()
	print "Looking at channel list:\n", "\n".join( map(lambda cl: ":".join(cl), channels) )
=======
	channels = map( lambda cl: ":".join(cl), channels )
	channels.sort()
	print "Looking at channel list:\n", "\n".join( channels )
>>>>>>> Stashed changes
else:
	# TODO: Fix this -- it's stupid
	channels.sort()
	print "Looking at channel list:\n", "\n".join( channels )
<<<<<<< Updated upstream
	channels = [ c.split(":") for c in channels ]

# construct tf map extent
fig = pyplot.figure(figsize=(10,len(channels)*5))
#gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 2, width_ratios=[30,1])#, hspace=0.3 )
gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 1 )

for i, chan in enumerate(channels):
	inst, channel = chan
	ax = pyplot.subplot(gs[i])

	# Extent in time
	ax.set_xlim(viewseg[0], viewseg[1])
	# Extent in frequency
	# FIXME: Different Channels won't have the same frequency settings
	ax.set_ylim(opts.low_frequency, opts.high_frequency)

	sys.stdout.write( "Filtering %d events... " % len(events) )
	selected_events = [ event.snr for event in events if event.channel == channel and event.ifo == inst and event.central_freq < opts.high_frequency and event.central_freq > opts.low_frequency and event.peak_time in viewseg ]
	print "%d events remain." % len(selected_events)
	selected_events.sort()
	selected_events = numpy.array( selected_events )

	# what's our snr scale
	# FIXME: look only at selected events
	snr_norm = matplotlib.colors.Normalize( 
		selected_events[0], selected_events[-1] 
	)
=======
	#channels = [ c.split(":") for c in channels ]

# construct tf map extent
fig = pyplot.figure(figsize=(15,len(channels)*7), dpi=160)
#gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 2, width_ratios=[30,1])#, hspace=0.3 )
gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 1 )

i=0
events.sort(key=lambda e: e.ifo + ":" + e.channel) # Required for groupby
for channel, selected_events in itertools.groupby( events, lambda e: e.ifo + ":" + e.channel ):
	if( channel not in channels ): continue

	sys.stdout.write( "Filtering %d events... " % len(events) )
	selected_events = filter( lambda event: event.central_freq < opts.high_frequency and event.central_freq > opts.low_frequency and event.snr > opts.snr_thresh and event.peak_time in viewseg, selected_events )
	#selected_events = [ event.snr for event in events if event.channel == channel and event.ifo == inst and event.central_freq < opts.high_frequency and event.central_freq > opts.low_frequency and event.snr > opts.snr_thresh and event.peak_time in viewseg ]
	print "%d events remain." % len(selected_events)
	if( len(selected_events) == 0 ):
		print "No events remain, skipping."
		continue

	inst, channel = channel.split(":")

	ax = pyplot.subplot(gs[i])
	# Extent in time
	ax.set_xlim(viewseg[0], viewseg[1])
	# Extent in frequency
	# FIXME: Different channels won't have the same frequency settings
	ax.set_ylim(opts.low_frequency, opts.high_frequency)

	selected_events.sort(key=lambda e: e.snr)
	selected_events = numpy.array( selected_events )

	# what's our snr scale
	if( len(selected_events) > 0 ):
		snr_norm = matplotlib.colors.Normalize( 
			selected_events[0].snr, selected_events[-1].snr
		)
	else:
		snr_norm = matplotlib.colors.Normalize( 0, 1 )

>>>>>>> Stashed changes
	colormap = matplotlib.cm.ScalarMappable( norm = snr_norm, cmap = matplotlib.cm.jet )

	# Make me purty
	ax.grid()
	if( opts.mark_time in viewseg ):
		pyplot.axvline(opts.mark_time, color="k")

	if( i == len(channels)-1 ):
		pyplot.xlabel( "Time (s)" )
	pyplot.ylabel( "Frequency (Hz)" )
	title = "channel: %s, inst %s" % (channel, inst)
	if( i == 0 ):
		title = "Tile energy time frequency map\n%s" % title
	pyplot.title( title )

	# construct tiles
	# FIXME: Partition events first
	for event in selected_events:
		# 1. plot tile 
		start = event.get_peak()# + event.start_time_ns*1e-9
		tile = matplotlib.patches.Rectangle(
			# lower left point
			( start,
			# FIXME: Presumes tile energy is uniform in frequency
			(event.central_freq - event.bandwidth/2.0) ),
			# tile extent
			event.duration,
			event.bandwidth,
			color = colormap.to_rgba( event.snr )
		)
		ax.add_patch( tile )

	divider = make_axes_locatable(ax)
	cax = divider.append_axes( "right", size="5%", pad=0.1 )
	cbl = matplotlib.colorbar.ColorbarBase( cax, cmap=matplotlib.cm.jet, norm=snr_norm, orientation="vertical" )
<<<<<<< Updated upstream
	cbl.set_label( "SNR" )
=======
	cbl.set_label( "Tile Energy" )

	snrs = numpy.array([e.snr for e in selected_events])
	if( opts.enable_event_hist ):
		sax = divider.append_axes( "right", size="50%", pad=0.7 )
		#pyplot.hist( selected_events**2, log=True )
		pyplot.hist( snrs*0.62, log=True )
		dof = events[0].chisq_dof
		tfmap_area = abs(viewseg)*(opts.high_frequency-opts.low_frequency)
		#dist = chi2(dof).pdf( selected_events**2 )*tfmap_area/dof
		# magic number to get the effective DOF = 0.62
		dist = chi2(dof*0.62).pdf( snrs*0.62 )*tfmap_area/dof
		pyplot.semilogy()
		pyplot.plot( snrs, dist, "r-", label="$\chi_{%d}^2$" % dof )
		sax.yaxis.set_ticks_position( "right" )
		pyplot.locator_params(nbins=3, axis="x")
		pyplot.xlabel( "Tile Energies" )
		pyplot.legend()

	#inset_ax = inset_axes( ax, width="20%", height="33%", loc=4 )
	#pyplot.locator_params(nbins=3, axis="x")

	i += 1

>>>>>>> Stashed changes

	if( opts.enable_event_hist ):
		sax = divider.append_axes( "right", size="50%", pad=0.7 )
		#pyplot.hist( selected_events**2, log=True )
		pyplot.hist( selected_events, log=True )
		dof = events[0].chisq_dof
		#dof /= 0.68 # magic number to get the actual DOF
		tfmap_area = abs(viewseg)*(opts.high_frequency-opts.low_frequency)
		#dist = chi2(dof).pdf( selected_events**2 )*tfmap_area/dof
		dist = chi(dof).pdf( selected_events )*tfmap_area/dof
		pyplot.semilogy()
		pyplot.plot( selected_events, dist, "r-", label="$\chi_{%d}$" % dof )
		sax.yaxis.set_ticks_position( "right" )
		pyplot.locator_params(nbins=3, axis="x")
		pyplot.xlabel( "Tile Amplitudes" )
		pyplot.legend()

	#inset_ax = inset_axes( ax, width="20%", height="33%", loc=4 )
	#pyplot.locator_params(nbins=3, axis="x")

	# Event rate plot


filename = opts.output_file or "trigmap"
if( opts.mark_time ): filename += "_%d" % int(opts.mark_time)
fig.savefig( "%s.png" % filename )
