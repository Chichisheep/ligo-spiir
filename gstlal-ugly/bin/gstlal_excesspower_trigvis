#!/usr/bin/env python
#
# Copyright (C) 2012 Chris Pankow
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""Visualizer for SnglBurst events"""

import sys

import matplotlib
import matplotlib.gridspec
matplotlib.use("Agg")
from matplotlib import pyplot
from matplotlib.collections import PatchCollection

# FIXME: This doesn't seem to work with python-2.7 on macs
#matplotlib.rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})

from mpl_toolkits.axes_grid.inset_locator import inset_axes
from mpl_toolkits.axes_grid import make_axes_locatable

from scipy.stats import chi2, chi

import numpy
import math

import itertools

from glue.ligolw import utils
from glue.ligolw import lsctables
from glue import segments
from glue.lal import LIGOTimeGPS

from optparse import OptionParser

parser = OptionParser()
parser.add_option("-c", "--channels", action="store", help="Comma separated list of channels. Will plot triggers only from the channels indicated. Otherwise, all channels will be plotted.")
parser.add_option("-o", "--output-file", action="store", help="File to output image to. Default: trigmap.png")
parser.add_option("-i", "--instruments", action="store", help="Comma separates list of instruments. Will plot channels only from the instruments indicated. Otherwise, all no instrument selection is done.")
parser.add_option("-s", "--gps-start", action="store", type=float, help="Plot triggers only after indicated gps time. Default is to infer from triggers.")
parser.add_option("-e", "--gps-end", action="store", type=float, help="Plot triggers only before indicated gps time. Default is to infer from triggers.")
parser.add_option("-f", "--low-frequency", action="store", type=float, default=32.0, help="Plot trigggers with central frequency above this frequency. Default is 32.")
parser.add_option("-F", "--high-frequency", action="store", type=float, default=2000.0, help="Plot trigggers with central frequency below this frequency. Default is 2000.")
parser.add_option("-S", "--snr-thresh", action="store", type=float, default=0.0, help="Plot trigggers with snr greater than that indicated.")
parser.add_option("-m", "--mark-time", action="store", type=float, help="Mark a particular time on the map. Useful for identifying triggers in a file spanning a large time.")
parser.add_option("-M", "--mark-loudest", action="store", default=None, help="Mark a specific event in the title. Two choices are available 'snr' and 'conf'. 'snr' will mark the loudest event by SNR, and 'conf' will mark the most confident event.")
parser.add_option("-r", "--enable-event-hist", action="store_true", help="Enable the subplot with event rate versus strength for the channel.")
#parser.add_option("-w", "--ignore-whitener", action="store", type=float, default=20.0, help="Ignore the first N seconds of data (from whitening effects), default is 20.")
parser.add_option("-x", "--overlay-segments", action="store", help="The entries for this argument are parsed and if segments with those definitions exist in the viewsegment, they will be overlayed on the plot.")

opts, args = parser.parse_args()

plot_sim = False

if( opts.mark_loudest not in [None, 'snr', 'conf'] ):
	exit( "Invalid argument to '--mark-loudest', please choose one of 'snr' or 'conf'" )

if( opts.channels is not None ):
	channels = opts.channels.split(",")
else: channels = None

if( plot_sim ):
	channels = [ "Simulation" ]
	instruments = [ "Z" ]

if( opts.instruments is not None ):
	print instruments
else: instruments = None

if( opts.overlay_segments is not None ): 
	segment_defs = opts.overlay_segments.split(",")
else:
	segment_defs = None

######## HACK ALERT ###########
# This is only done so that sim events can be treated more like SnglBurst entries
# TODO: Doesn't work.
#lsctables.SimBurst = lsctables.table.RowType
###############################

events = lsctables.SnglBurstTable()
for arg in args:
	xmldoc = utils.load_filename( arg )
	if( not plot_sim ):
		for tbl in lsctables.getTablesByType( xmldoc, lsctables.SnglBurstTable ):
			events += tbl 
	else:
		# TODO: Fix this -- see hack alert above
		for tbl in lsctables.getTablesByType( xmldoc, lsctables.SimBurstTable ):
			tbl.validcolumns['snr'] = 'real_8'
			tbl.appendColumn( "amplitude" )
			events += tbl 
		events.validcolumns['snr'] = 'real_8'
		events.appendColumn( "snr" )
		for e in events:
			e.snr = 0
			try:
				if( e.amplitude is not None ): continue
			except AttributeError: pass # This is annoying!
			try:
				e.amplitude = e.hrss
			except AttributeError: pass
			try: 
				e.amplitude = e.egw_over_rsquared
			except AttributeError: 
				sys.exit( "Can't find a valid energy/amplitude for injection.")

if( instruments is None and channels is None ):
	instruments = {}
	for event in events:
		instruments[event.ifo] = None
	instruments = instruments.keys()
if( instruments is None ):
	instruments = {}
	for channel in channels:
		instruments[channel.split(":")[0]] = None
	instruments = instruments.keys()

print "Examining instruments: %s" % str(instruments)

# Segment information
segs = segments.segmentlistdict()
analyzed_segments = segments.segmentlistdict()
for arg in args:
	xmldoc = utils.load_filename( arg )
	def_id_pair = []
	if( segment_defs is not None ):
		segtables = lsctables.SegmentDefTable()
		for tbl in lsctables.getTablesByType( xmldoc, lsctables.SegmentDefTable ):
			segtables += tbl 

		# TODO: Reject if ifo isn't in acceptable list
		def_id_pair = [ (r.segment_def_id, r.name, unicode(r.ifos)) for r in segtables ]
		def_id_pair = filter( lambda (i,n,j): n in segment_defs and j in instruments, def_id_pair )
		def_id_pair = dict(map( lambda (i,n,j): (i,(n,j)), def_id_pair ))

	if( len(def_id_pair) > 0 ):
		for i, ids in def_id_pair.iteritems(): 
			segs[ids] = segments.segmentlist()

		segtables = lsctables.SegmentSumTable()
		for tbl in lsctables.getTablesByType( xmldoc, lsctables.SegmentSumTable ):
			segtables += tbl 

		for seg in segtables:
			# FIXME: Doesn't work because Segment table doesn't have ns
			#segm = seg.get()
			segm = segments.segment(LIGOTimeGPS(seg.start_time), LIGOTimeGPS(seg.end_time)) 
			if seg.segment_def_id in def_id_pair.keys() and viewseg.intersects(segm):
				segs[def_id_pair[seg.segment_def_id]].append( segm )

	# search segment data and event filtering
	try:
		searches = lsctables.getTablesByType( xmldoc, lsctables.SearchSummaryTable )[0]
		# FIXME: This is gonna be slow for lots of runs need to partition on pid and reconstitute the event list after filtering
		for search in searches:
			pid, oseg = search.process_id, search.get_out()
			for i in range(len(events))[::-1]:
				if( events[i].process_id == pid and not events[i].peak_time in oseg ):
				# TODO: Check we don't mess up the internal list structure doing this
					del events[i]

		analyzed_segments = searches.get_out_segmentlistdict()

	except IndexError: 
		pass

viewseg = segments.segment( segments.NegInfinity, segments.PosInfinity )
if( opts.gps_start is None ):
	viewseg = segments.segment( min([e.peak_time for e in events]), viewseg[1] )
else: viewseg = segments.segment( opts.gps_start, viewseg[1] )
if( opts.gps_end is None ):
	viewseg = segments.segment( viewseg[0], max([e.peak_time for e in events]) )
else: viewseg = segments.segment( viewseg[0], opts.gps_end )
viewseg = segments.segment( viewseg[0], viewseg[1] )

# FIXME: Return to this when the ifos situation is sorted out
analyzed_segments.coalesce()
# Invert to get non-analyzed periods
analyzed_segments = analyzed_segments.__invert__()

# Channel information
if( channels is None ):
	channels = {}
	for event in events:
		if( event.ifo in instruments ):
			channels[(event.ifo, event.channel)] = None
	channels = channels.keys()
	channels = map( lambda cl: ":".join(cl), channels )

channels.sort()
print "Looking at channel list:\n", "\n".join( channels )

# construct tf map extent
fig = pyplot.figure(figsize=(15,len(channels)*7), dpi=160)
#gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 2, width_ratios=[30,1])#, hspace=0.3 )
gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 1 )

pn=0
if( not plot_sim ):
	events.sort(key=lambda e: e.ifo + ":" + e.channel) # Required for groupby
	event_iter = itertools.groupby( events, lambda e: e.ifo + ":" + e.channel )
else:
	event_iter = [["Simulation", events]]

for channel, selected_events in event_iter:
	if( channel not in channels ): continue

	sys.stdout.write( "Filtering %d events... " % len(events) )
	if( plot_sim ):
		selected_events = filter( lambda event: event.frequency <= opts.high_frequency and event.frequency >= opts.low_frequency and event.amplitude >= opts.snr_thresh and event.time_geocent_gps in viewseg, selected_events )
	else:
		selected_events = filter( lambda event: event.central_freq <= opts.high_frequency and event.central_freq >= opts.low_frequency and event.snr >= opts.snr_thresh and event.peak_time in viewseg, selected_events )
	#selected_events = [ event.snr for event in events if event.channel == channel and event.ifo == inst and event.central_freq < opts.high_frequency and event.central_freq > opts.low_frequency and event.snr > opts.snr_thresh and event.peak_time in viewseg ]
	print "%d events remain." % len(selected_events)
	if( len(selected_events) == 0 ):
		print "No events remain, skipping."
		continue

	if( plot_sim ):
		inst, channel = "Sim", "Simulation"
	else:
		inst, channel = channel.split(":")

	ax = pyplot.subplot(gs[pn])
	# Extent in time
	ax.set_xlim(viewseg[0], viewseg[1])
	# Extent in frequency
	# FIXME: Different channels won't have the same frequency settings
	ax.set_ylim(opts.low_frequency, opts.high_frequency)

	if( plot_sim ):
		selected_events.sort(key=lambda e: e.amplitude)
	else:
		selected_events.sort(key=lambda e: e.snr)
	selected_events = numpy.array( selected_events )

	# what's our snr scale
	if( len(selected_events) > 0 ):
		snr_norm = matplotlib.colors.Normalize( 
			selected_events[0].snr, selected_events[-1].snr
			#numpy.log10(selected_events[0].snr), numpy.log10(selected_events[-1].snr)
		)
	else:
		snr_norm = matplotlib.colors.Normalize( 0, 1 )

	colormap = matplotlib.cm.ScalarMappable( norm = snr_norm, cmap = matplotlib.cm.jet )

	# Make me purty
	ax.grid()
	if( opts.mark_time in viewseg ):
		pyplot.axvline(opts.mark_time, color="k")

	if( i == len(channels)-1 ):
		pyplot.xlabel( "Time (s)" )
	pyplot.ylabel( "Frequency (Hz)" )

	# construct tiles
	statstr = "0% complete"
	sys.stdout.write( statstr )
	statlen = len(statstr)

	tiles, snrs = [], []
	loudest = [0,-1]
	for i, event in enumerate(selected_events):
		sys.stdout.write( "\b"*statlen )
		statstr = "%d%% complete" % numpy.round(float(i)/len(selected_events)*100)
		sys.stdout.write( statstr )
		statlen = len(statstr)
		# 1. plot tile 
		start = event.get_peak()# + event.start_time_ns*1e-9
		tile = matplotlib.patches.Rectangle(
			# lower left point
			( start,
			# FIXME: Presumes tile energy is uniform in frequency
			(event.central_freq - event.bandwidth/2.0) ),
			# tile extent
			event.duration,
			event.bandwidth
			#color = colormap.to_rgba( numpy.log10(event.snr) )
			#color = colormap.to_rgba( event.snr )
		)
		#ax.add_patch( tile )
		tiles.append( tile )
		snrs.append( event.snr )
		if( loudest[0] < event.snr and opts.mark_loudest == 'snr' ):
			loudest = [event.snr, float(event.get_peak()), event.central_freq]
		elif( loudest[0] < event.confidence and opts.mark_loudest == 'conf' ):
			loudest = [event.confidence, event.get_peak(), event.central_freq]

	print ""

	title = "channel: %s, inst %s" % (channel, inst)
	if( pn == 0 ):
		title = "Tile energy time frequency map\n%s" % title
	if( opts.mark_loudest is not None ):
		print "Loudest event at (%s)" % ", ".join(map(lambda a: str(a), loudest[1:]))
		pyplot.plot( [loudest[1]], [loudest[2]], marker='o', markerfacecolor='none', markersize=10, markeredgewidth=1.2)
		title += " loudest event (%s=%.3g): %10.1f" % (opts.mark_loudest, math.sqrt(loudest[0]), loudest[1])
	pyplot.title( title )


	# TODO: See if replacing data speeds up the process
	patches = PatchCollection( tiles, match_original = False, cmap = matplotlib.cm.jet, edgecolor='none', antialiased = False )
	patches.set_array( numpy.array(snrs) )
	ax.add_collection( patches )

	lastwrite = viewseg[0]
	# FIXME: This is empircal at best.
	tsize = 0.02*abs(viewseg)
	t = 0
	for (segdef, ifo), slist in segs.iteritems():
		if( ifo != inst ): continue
		for seg in slist:
			# Indicate the name and if the segment extent continues to left or right
			name = str(ifo+":"+segdef)
			if( seg[0] < viewseg[0] ):
				name = unichr(0x2191) + name 
			if( seg[1] > viewseg[1] ):
				name = name + unichr(0x2192) 

			seg = viewseg & seg 
			# Shouldn't happen, but just in case
			if( seg is None ): continue
			start, end = seg[0], seg[1]
			tile = matplotlib.patches.Rectangle(
				# lower left point
				( start, 0 ),
				# tile extent
				(end-start),
				opts.high_frequency,
				color = 'k',
				alpha = 0.1, hatch = "/"
			)

			# If multiple segment names would be written to the same area
			# move the text over. FIXME: This is not the definitive way to do 
			# this it's a hack at best
			if( lastwrite == start ):
				lastwrite += tsize*t
				t+=1
			else:
				lastwrite = start
				t = 0
			ax.text( lastwrite, 0.95*opts.high_frequency, name, rotation = "vertical" )
			ax.add_patch( tile )

	for (ifo, aseg) in analyzed_segments.iteritems():
		# TODO: what to do with this?
		continue
		if( ifo != inst ): continue
		for seg in aseg:
			# Indicate the name and if the segment extent continues to left or right
			name = str(ifo+"_analyzed")
			if( seg[0] < viewseg[0] ):
				name = unichr(0x2191) + name 
			if( seg[1] > viewseg[1] ):
				name = name + unichr(0x2192) 

			seg = viewseg & seg 
			# Shouldn't happen, but just in case
			if( seg is None ): continue
			start, end = seg[0], seg[1]
			tile = matplotlib.patches.Rectangle(
				# lower left point
				( start, 0 ),
				# tile extent
				(end-start),
				opts.high_frequency,
				color = 'k',
				alpha = 0.1, hatch = "/"
			)

			# If multiple segment names would be written to the same area
			# move the text over. FIXME: This is not the definitive way to do 
			# this it's a hack at best
			if( lastwrite == start ):
				lastwrite += tsize*t
				t+=1
			else:
				lastwrite = start
				t = 0
			ax.text( lastwrite, 0.95*opts.high_frequency, name, rotation = "vertical" )
			ax.add_patch( tile )

	# Add colorbar
	divider = make_axes_locatable(ax)
	cax = divider.append_axes( "right", size="5%", pad=0.1 )
	cbl = matplotlib.colorbar.ColorbarBase( cax, cmap=matplotlib.cm.jet, norm=snr_norm, orientation="vertical" )
	cbl.set_label( "Tile Energy" )

	# If requested, make a histogram of the tile energies and compare to
	# expectation
	snrs = numpy.array([e.snr for e in selected_events])
	if( opts.enable_event_hist ):
		sax = divider.append_axes( "right", size="50%", pad=0.7 )
		#pyplot.hist( selected_events**2, log=True )
		pyplot.hist( snrs*0.62, log=True )
		dof = events[0].chisq_dof
		tfmap_area = abs(viewseg)*(opts.high_frequency-opts.low_frequency)
		#dist = chi2(dof).pdf( selected_events**2 )*tfmap_area/dof
		# magic number to get the effective DOF = 0.62
		dist = chi2(dof*0.62).pdf( snrs*0.62 )*tfmap_area/dof
		pyplot.semilogy()
		pyplot.plot( snrs, dist, "r-", label="$\chi_{%d}^2$" % dof )
		sax.yaxis.set_ticks_position( "right" )
		pyplot.locator_params(nbins=3, axis="x")
		pyplot.xlabel( "Tile Energies" )
		pyplot.legend()

	#inset_ax = inset_axes( ax, width="20%", height="33%", loc=4 )
	#pyplot.locator_params(nbins=3, axis="x")

	pn += 1

# Drop the file
filename = opts.output_file or "trigmap"
if( opts.mark_time ): filename += "_%d" % int(opts.mark_time)
fig.savefig( "%s.png" % filename )
