#!/usr/bin/python
import sys, os, socket, re
import glob, math, shutil
from glue import cbcwebpage
from glue import lal
from glue import segments
from optparse import OptionParser

from pylal import git_version
__author__ = "Chad Hanna <channa@ligo.caltech.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


def parse_command_line():
	parser = OptionParser(version = git_version.verbose_msg, usage = "%prog [options] [file ...]", description = "%prog summary web page")
	parser.add_option("--webserver-dir", help = "Set the directory for the webserver.  Required.  Example /archive/home/channa/public_html/highmass_months_23-24_summary_page")
	parser.add_option("--open-box", action = "store_true", help = "Produce open box page")
	parser.add_option("--output-name-tag",default = "", metavar = "name", help = "Set the basename for image search")
	parser.add_option("--title", default="S5 sub solar mass search")

	opts, filenames = parser.parse_args()
	return opts, filenames

# PARSE THE COMMAND LINE
opts, files = parse_command_line()
base_name = opts.output_name_tag
file_base = os.path.split(base_name)[1]
search = base_name.replace('_',' ')

# INITIALIZE THE PAGE OBJECT
page = cbcwebpage.cbcpage(title=opts.title)

# WELCOME MESSAGE PAGE
page.front = "<big>Welcome</big>"

### Summary info. 
page.add_subpage("summary", "Summary information", "Summary information")
page.subpages["summary"].div("""
Summary information
""")
tab, name = cbcwebpage.wiki_table_parse(base_name+'num_trigs_table.txt')
page.subpages["summary"].add_table(tab[0], "This is a summary table", "This is a summary table")

### INJ PARAM PAGE ###
page.add_subpage("injection_params","Injection Parameters", "Injection Parameters")

page.subpages["injection_params"].div("""
<big><b>OVERVIEW:</b></big><br><br>
Injections are the addition of simulated signals into the gravitational wave strain data.  They are useful 
for diagnosing the pipeline and measuring the sensitivity.  Care is taken to assure that the input 
distribution is sensible.  The remaining sections describe the input distributions for the injections.  
They are not necessarily what is analyzed since the analyzed segments are not used for determining the
injection sets (i.e. injections may be scheduled for times when a detector is not even functioning).
<br><br>The following plots are typically produced by injection waveform type.  Several injection runs
of the same waveform (with different random seeds) are often done.  Here all runs of the same waveform type
are shown together.
""")

page.subpages["injection_params"].add_section("m1_m2","Injected Parameters m1 and m2")
imgtable = cbcwebpage.image_glob(base_name+'6_sim_dist_m1_m2*.png')
page.subpages["injection_params"].sections["m1_m2"].add_table(imgtable, "Injected mass1, mass2", "Above are the injected mass parameters for the simulations done.  Typically injections are done uniformally in component mass unless the waveform approximant cannot support certain mass ratios.")

page.subpages["injection_params"].add_section("time_dist","Injected Parameters time and distance")
imgtable = cbcwebpage.image_glob(base_name+'6_sim_dist_time_distance*.png')
page.subpages["injection_params"].sections["time_dist"].add_table(imgtable, "Injection time and distance", "Unless doing a directed search injections are uniform in time.  Although the correct distance distribution would be uniform in volume typically logarithmic injections are done")

page.subpages["injection_params"].add_section("ra_dec","Injected Parameters RA and DEC")
imgtable = cbcwebpage.image_glob(base_name+'6_sim_dist_ra_dec*.png')
page.subpages["injection_params"].sections["ra_dec"].add_table(imgtable, "Injection RA and DEC", "Unless doing a directed search injections are uniform on the sky.")

page.subpages["injection_params"].add_section("inc_pol","Injected Parameters inclination and polarization")
imgtable = cbcwebpage.image_glob(base_name+'6_sim_dist_inc_pol*.png')
page.subpages["injection_params"].sections["inc_pol"].add_table(imgtable, "Injection Inclination and polarization", "Unless doing a directed search injections are uniform in inclination and polarizations.  Note that there was a bug introduced into inspinj that caused polarizations to be set to zero.")

page.subpages["injection_params"].add_section("spin","Injected Parameters Z component spin")
imgtable = cbcwebpage.image_glob(base_name+'6_sim_dist_spin1z_spin2z*.png')
page.subpages["injection_params"].sections["spin"].add_table(imgtable, "Injection spin 1z and spin2z", "The Z component spins of the injection set.  Often injections are done without spin, so don't be surprised if these are zero.")


### INJ ACC PAGE ###
page.add_subpage("injection_params_acc","Injection Parameters Accuracy", "Injection Accuracy")
page.subpages["injection_params_acc"].div("""
<big><b>OVERVIEW:</b></big><br><br>
The accuracy of recovered parameters aids at diagnosing the performance of the pipeline as well as
hinting at the possibility of measuring certain parameters.  Mass parameters for the low mass search 
are often recovered better than mass parameters for the high mass search.  
""")

page.subpages["injection_params_acc"].add_section("mchirp_param_acc","Mchirp Parameter Accuracy")
imgtable = cbcwebpage.image_glob(base_name+'2_mchirp_acc_frac_*.png')
page.subpages["injection_params_acc"].sections["mchirp_param_acc"].add_table(imgtable, "Mchirp Accuracy", "Accuracy of chirp mass.")
page.subpages["injection_params_acc"].add_section("eta_param_acc","Eta Parameter Accuracy")
imgtable = cbcwebpage.image_glob(base_name+'2_eta_acc_frac_*.png')
page.subpages["injection_params_acc"].sections["eta_param_acc"].add_table(imgtable, "Eta Accuracy", "Accuracy of eta")
page.subpages["injection_params_acc"].add_section("time_param_acc","Time Parameter Accuracy")
imgtable = cbcwebpage.image_glob(base_name+'2_t_acc_*.png')
page.subpages["injection_params_acc"].sections["time_param_acc"].add_table(imgtable, "Time Accuracy", "Accuracy of time")

### MISSED FOUND ###
page.add_subpage("missed_found","Missed Found", "Missed Found")
#page.subpages["missed_found"].add_section("overview","Missed found injections overview")
page.subpages["missed_found"].div("""
<big><b>OVERVIEW:</b></big><br><br>
Measuring the found and missed injections as a function of various parameters aids in diagnosing the 
pipeline as well as providing the expected sensitivity of the pipeline to real signals.  The plots in
this section show the missed and found injections as a for the various IFO times for coincident triggers.
We allow double coincident events so some categories can have multiple types of found injections (for
 example H1L1 and H1H2L1 triggers in H1H2L1 time).  Because of ambiguity concerning the time of an 
injection and the injection window it is occasionally possible to find an injection in more detectors
than what the "time" refers to.  For example, an injection's geocentric end time might be in H1L1 time
but that might occur near a boundary where H2 was also on.  Thus one could find an H1L1 injection in
H1H2L1 time.
""")
tab,name = cbcwebpage.wiki_table_parse(base_name+'injection_summary.txt')
page.subpages["missed_found"].add_table(tab[0], "Injection Summary Table", "Summary of missed and found injections broken up by detector time")

page.subpages["missed_found"].add_section("found_missed_mchirp","Found / Missed Chirp Mass")
imgtable = cbcwebpage.image_glob(base_name+'1_deff_vs_mchirp_*.png')
page.subpages["missed_found"].sections["found_missed_mchirp"].add_table(imgtable, "Missed Found Effective Distance vs Mchirp", "Effective distance of found and missed injections as a function of chirp mass")
imgtable = cbcwebpage.image_glob(base_name+'1_chirpdist_vs_mchirp_*.png')
page.subpages["missed_found"].sections["found_missed_mchirp"].add_table(imgtable, "Missed Found Chirp Distance vs Mchirp", "Chirp distance of found and missed injections as a function of chirp mass.  For low mass systems the chirp mass scales out of the expected amplitude.  The chirp distance utilizes this and rescales the distance to be appropriate for a NS-NS binary.  At low total mass the missed/found barrier should be flat on this plot.")

page.subpages["missed_found"].add_section("found_missed_mtotal","Found / Missed Total Mass")
imgtable = cbcwebpage.image_glob(base_name+'1_deff_vs_mtotal_*.png')
page.subpages["missed_found"].sections["found_missed_mtotal"].add_table(imgtable, "Missed Found Effective Distance vs M total", "Effective distance of found and missed injections as a function of total mass")


page.subpages["missed_found"].add_section("found_missed_time","Found / Missed Time")
imgtable = cbcwebpage.image_glob(base_name+'1_deff_vs_t_*.png')
page.subpages["missed_found"].sections["found_missed_time"].add_table(imgtable, "Missed Found vs Time", "Effective distance of found and missed injections as a function of time")


#
# CLOSED BOX
#

if not opts.open_box:
	
	### CHISQ ###
	page.add_subpage("chisq","Chi-squared", "Chi-squared")
	page.subpages["chisq"].div("""
<big><b>OVERVIEW:</b></big><br><br>
The chi-squared test checks that the snr accumulated matches expectation. 
FIXME
	""")
	page.subpages["chisq"].add_section("chisq","Chi-squared vs SNR")
	imgtable = cbcwebpage.image_glob(base_name+'3_chi2_vs_rho_*closedbox.png')
	page.subpages["chisq"].sections["chisq"].add_table(imgtable, "Chi-squared Vs SNR", "Chi-squared vs snr for single detectors after coincidence.  Blue points are full data zero lag, red are software injections and black are time slides.")

	### Money Plots ###
	page.add_subpage("money","Money Plots", "Money Plots")
	page.subpages["money"].div("""
<big><b>OVERVIEW:</b></big><br><br>
This section provides the detection statistic plots and a summary of the loudest event.  The ranking statistic is inverse false alarm rate (IFAR)
""")
	page.subpages["money"].add_section("ifar","Rate vs. IFAR Threshold")
	imgtable = cbcwebpage.image_glob(base_name+'5_count_vs_ifar*closedbox.png')
	page.subpages["money"].sections["ifar"].add_table(imgtable, "Rate vs. IFAR Threshold", "Comparison of observed zero-lag event rate to event rate expected from background as a function of inverse false-alarm rate (IFAR) threshold.")
	page.subpages["money"].add_section("table","Loudest Table")
	tab,name = cbcwebpage.wiki_table_parse(base_name+'bgsummary_table.txt')
	page.subpages["money"].sections["table"].add_table(tab[0], "Closed Box Summary Table", "Loudest Events")

#
# OPEN BOX
#

else:
	print >>sys.stderr, "WARNING: OPENING THE BOX"
	
	### CHISQ ###
	page.add_subpage("chisq","Chi-squared", "Chi-squared")
	page.subpages["chisq"].div("""
<big><b>OVERVIEW:</b></big><br><br>
The chi-squared test checks that the snr accumulated matches expectation. 
FIXME
	""")
	page.subpages["chisq"].add_section("chisq","Chi-squared vs SNR")
	imgtable = cbcwebpage.image_glob(base_name+'3_chi2_vs_rho_*openbox.png')
	page.subpages["chisq"].sections["chisq"].add_table(imgtable, "Chi-squared Vs SNR", "Chi-squared vs snr for single detectors after coincidence.  Blue points are full data zero lag, red are software injections and black are time slides.")

	### Money Plots ###
	page.add_subpage("money","Money Plots", "Money Plots")
	page.subpages["money"].div("""
<big><b>OVERVIEW:</b></big><br><br>
This section provides the detection statistic plots and a summary of the loudest event.  The ranking statistic is inverse false alarm rate (IFAR)
""")
	page.subpages["money"].add_section("ifar","Rate vs. IFAR Threshold")
	imgtable = cbcwebpage.image_glob(base_name+'5_count_vs_ifar*openbox.png')
	page.subpages["money"].sections["ifar"].add_table(imgtable, "Rate vs. IFAR Threshold", "Comparison of observed zero-lag event rate to event rate expected from background as a function of inverse false-alarm rate (IFAR) threshold.")
	page.subpages["money"].add_section("table","Loudest Table")
	tab,name = cbcwebpage.wiki_table_parse(base_name+'summary_table.txt')
	page.subpages["money"].sections["table"].add_table(tab[0], "Summary Table", "Loudest Events")

	### UPPER LIMIT PLOTS ###
	#page.add_subpage("ul","Upper Limit Plots", "Upper Limit Plots")
	#page.subpages["ul"].div("""
#<big><b>OVERVIEW:</b></big><br><br>
#This section describes the upperlimit calculation which is a 90% confidence upper limit on the rate of mergers with units mergers/Mpc^3/year as a function of mass.  Various 
#quantities go into this calculation.  They are shown here. 
#""")

	#range_summs = glob.glob(base_name+'-*_range_summary.txt')
	#for rs in range_summs:
	#	tag = rs.replace('_',' ').replace('.txt','')
	#	page.subpages["ul"].add_section(tag,rs)
	#	tab,name = cbcwebpage.wiki_table_parse(rs)
	#	page.subpages["ul"].sections[tag].add_table(tab[0], "Range Summary", "Range summary")

	#page.subpages["ul"].add_section("vt","Volume x time")
	#imgtable = cbcwebpage.image_glob(base_name+'-*_volume_time.png')
	#page.subpages["ul"].sections["vt"].add_table(imgtable, "Volume x time", "mass1 mass2 volume x time")

	#page.subpages["ul"].add_section("evt","Error on Volume x time")
	#imgtable = cbcwebpage.image_glob(base_name+'-*_fractional_error.png')
	#page.subpages["ul"].sections["evt"].add_table(imgtable, "Error on Volume x time", "Error on mass1 mass2 volume x time")

	#page.subpages["ul"].add_section("l","Lambda")
	#imgtable = cbcwebpage.image_glob(base_name+'-*_lambda.png')
	#page.subpages["ul"].sections["l"].add_table(imgtable, "Lambda", "likelihood fg/bg @ loudest event")

	#page.subpages["ul"].add_section("p","Posterior")
	#imgtable = cbcwebpage.image_glob(base_name+'-*_posterior.png')
	#page.subpages["ul"].sections["p"].add_table(imgtable, "Posterior", "Poseterior on the rate")

	#page.subpages["ul"].add_section("ul","90% Upper limit")
	#imgtable = cbcwebpage.image_glob(base_name+'-*_upper_limit.png')
	#page.subpages["ul"].sections["ul"].add_table(imgtable, "90% Upper limit", "90% upper limit")

	#page.subpages["ul"].add_section("cul","Combined 90% Upper limit")
	#imgtable = [[cbcwebpage._imagelinkcpy(base_name+'upper_limit.png'), cbcwebpage._imagelinkcpy(base_name+'posterior.png')]]
	#page.subpages["ul"].sections["cul"].add_table(imgtable, "Combined 90% Upper limit", "Combined 90% upper limit")

	
if opts.open_box: page.write(file_base+"open_box")
else: page.write(file_base+"closed_box")

# copy the output
if opts.webserver_dir:
	for f in page.fnames: 
		shutil.copy(f,opts.webserver_dir)
	#FIXME not the best way to do this, I should explicitely save file names
	try: os.mkdir(opts.webserver_dir+'/Images')
	except: pass
	for f in glob.glob('Images/*.png'):
		shutil.copy(f,opts.webserver_dir+'/Images')
