#!/usr/bin/python

import sys
import numpy
from scipy import interpolate
from scipy.stats import poisson
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import process as ligolw_process
from glue.ligolw.utils import segments as ligolw_segments
from pylal import inject
from pylal import rate
from optparse import OptionParser
from gstlal import ligolw_output as gstlal_likelihood
from gstlal.svd_bank import read_bank
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3

sqlite3.enable_callback_tracebacks(True)

def smooth_bins(bA, stride = 5):
	wn = rate.gaussian_window2d(3 * stride, 3 * stride, sigma = 10)
	rate.filter_array(bA.array.T, wn)

def decimate_array(arr, stride = 5):
	return arr[::stride, ::stride]

def linearize_array(arr):
	return arr.reshape((1,arr.shape[0] * arr.shape[1]))

def get_nonzero(arr):
	return arr[arr != 0]


class FAR(object):
	def __init__(self, livetime, trials_factor, counts = None):
		self.counts = counts
		self.livetime = livetime
		self.trials_factor = trials_factor
		if counts is not None:
			H1nonzero = get_nonzero(linearize_array(decimate_array(counts["H1_snr_chi"].array, stride = options.stride)))
			L1nonzero = get_nonzero(linearize_array(decimate_array(counts["L1_snr_chi"].array, stride = options.stride)))
			self.ranks = self.possible_ranks_array(H1nonzero, L1nonzero)

			# compute the false alarm probability (FAP) from possible ranks
			FAP = (numpy.arange(len(self.ranks)) + 1.) / len(self.ranks)
			self.fap_from_rank = interpolate.interp1d(self.ranks, FAP, fill_value = 0., bounds_error = False)

	# Method only works if counts is not None:
	def possible_ranks_array(self, A, B):
		if self.counts is None:
			raise InputError, "must provide background bins file"
		out = numpy.outer(A, B)
		out = out.reshape((out.shape[0] * out.shape[1],))
		out.sort()
		return out

	# Method only works if counts is not None:
	def compute_rank(self, H1snr, H1chisq, L1snr, L1chisq):
		if self.counts is None:
			raise InputError, "must provide background bins file"
		rank = self.counts["H1_snr_chi"][H1snr, H1chisq**.5 / H1snr] * self.counts["L1_snr_chi"][L1snr, L1chisq**.5 / L1snr]
		if rank > self.ranks[-2]:
			rank = self.ranks[-2]
		return rank

	# Method only works if counts is not None:
	def compute_fap(self, H1snr, H1chisq, L1snr, L1chisq):
		if self.counts is None:
			raise InputError, "must provide background bins file"
		fap = self.fap_from_rank(self.compute_rank(H1snr, H1chisq, L1snr, L1chisq))[0]
		fap = 1.0 - (1.0 - fap)**self.trials_factor
		return fap

	def FAR_from_FAP(self, fap, n = 1):
		# the n = 1 case can be done exactly.  That is good since it is
		# the most important.  FIXME it should be possible to code
		# exact solutions for other small values of n that may be
		# imporant once detections are routine :)
		if n == 1:
			return 0. - numpy.log(1. - fap) / self.livetime
		if n > 1 and n <= 100:
			nvec = numpy.linspace(n**2 / 10000., n + 10. * n**.5, 100)
		else:
			nvec = numpy.linspace(n - 10. * n**.5, n + 10. * n**.5, 100)
		FAPS = 1. - poisson.cdf(n,nvec)
		interp = interpolate.interp1d(FAPS, nvec / self.livetime)
		if fap < FAPS[1]:
			return 0.
		if fap > FAPS[-1]:#This means that the FAP has gone off the edge.  We will bump it down because we don't really care about this being right.
			fap = FAPS[-1]
		return interp(fap)[0]

	def compute_far(self, fap, n):
		if fap == 0.0:
			far = 0.
		else:
			far = self.FAR_from_FAP(fap, n)
		return far


def parse_command_line():
	parser = OptionParser(
		description = __doc__
	)
	parser.add_option("--background-bins-file", metavar = "filename", action = "append", help = "Set the name of the xml file containing the snr / chisq background distributions")
	parser.add_option("--segments-file", metavar = "filename", help = "Set the name of the xml file containing analysis segments.")
	parser.add_option("--segments-name", metavar = "name", default = "datasegments", help = "Set the name of the analysis segments (default = 'datasegments').")
	parser.add_option("--vetoes-file", metavar = "filename", help = "Set the name of the xml file containing the veto segments.")
	parser.add_option("--vetoes-name", metavar = "name", default = "vetoes", help = "Set the name of the vetoes segments (default = 'vetoes').")
	parser.add_option("--stride", metavar = "int", type="int", default=5, help = "set the stride to decimate the bins, default 5")
	parser.add_option("--additional-trials-factor", metavar = "int", type="int", default=1, help = "set an additional trials factor to apply to the rate, beyond what is measured from the SVD.  Default is 1.")
	parser.add_option("--tmp-space", metavar = "dir", help = "Set the name of the tmp space if working with sqlite")
	parser.add_option("--compute-fap", action = "store_true", help = "compute fap, otherwise compute far assuming fap has been calculated")
	parser.add_option("--compute-far", action = "store_true", help = "compute far, only works if fap is being computed or has been computed.")
	parser.add_option("--verbose", "-v", action = "store_true", help = "Be verbose.")

	options, filenames = parser.parse_args()
	return options, filenames


# Parse command line
options, filenames = parse_command_line()

# load segment data
segments = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.segments_file, verbose = options.verbose), options.segments_name).coalesce()
vetoes = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.vetoes_file, verbose = options.verbose), options.vetoes_name).coalesce()

#FIXME for now our live time is defined by this
H1L1livetime = float(abs((segments - vetoes).intersection(set(("H1", "L1")))))

if options.compute_fap:
	# retrieve rank data
	coincparamsdistributions, likelihood_seglists = gstlal_likelihood.load_likelihood_data(options.background_bins_file, verbose = options.verbose)
	print >>sys.stderr, "smoothing bin counts ..."
	#coincparamsdistributions.finish(filters = gstlal_likelihood.DistributionsStats.filters, verbose = options.verbose)
	# FIXME:  the smoothing should be done with the .finish() method.
	# FIXME:  make sure the smoothing is what is intended:  what's coded here
	# is neither computing a sliding average of bin counts, nor an event rate
	# density.
	counts = coincparamsdistributions.background_rates
	for binned_array in counts.values():
		smooth_bins(binned_array, stride = options.stride)

	print >>sys.stderr, "computing FAP map preliminaries..."
	Far = FAR(H1L1livetime, options.additional_trials_factor, counts)
else:
	Far = FAR(H1L1livetime, options.additional_trials_factor)

# iterate over files to rank
for f in filenames:

	from glue.ligolw import dbtables

	working_filename = dbtables.get_connection_filename(f, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)

	connection.create_function("fap", 4, Far.compute_fap)
	connection.create_function("far", 2, Far.compute_far)

	if options.compute_fap is not None:
		print >>sys.stderr, "computing faps ..."
		# FIXME abusing FAR column
		connection.cursor().execute('UPDATE coinc_inspiral SET false_alarm_rate = (SELECT fap(snglA.snr, snglA.chisq, snglB.snr, snglB.chisq) FROM coinc_event_map as mapA on mapA.coinc_event_id == coinc_inspiral.coinc_event_id JOIN coinc_event_map as mapB on mapB.coinc_event_id == coinc_inspiral.coinc_event_id JOIN sngl_inspiral as snglA on snglA.event_id == mapA.event_id JOIN sngl_inspiral as snglB on snglB.event_id == mapB.event_id WHERE snglA.ifo == "H1" and snglB.ifo =="L1")')
		connection.commit()

	if options.compute_far is not None:
		ids = [id for id, in connection.cursor().execute("SELECT DISTINCT(time_slide_id) FROM time_slide")]
		for id in ids:
			print >>sys.stderr, "computing rates for ", id
			# FIXME abusing FAR column
			connection.cursor().execute('DROP TABLE IF EXISTS ranktable')
			# FIXME any indicies on ranktable??
			connection.cursor().execute('CREATE TEMPORARY TABLE ranktable AS SELECT * FROM coinc_inspiral JOIN coinc_event ON coinc_event.coinc_event_id == coinc_inspiral.coinc_event_id WHERE coinc_event.time_slide_id == ? ORDER BY false_alarm_rate', (id,))
			connection.cursor().execute('UPDATE coinc_inspiral SET combined_far = (SELECT far(ranktable.false_alarm_rate, ranktable.rowid) FROM ranktable WHERE ranktable.coinc_event_id == coinc_inspiral.coinc_event_id) WHERE coinc_inspiral.coinc_event_id IN (SELECT coinc_event_id FROM ranktable)')
	
	connection.close()
	dbtables.put_connection_filename(f, working_filename, verbose = options.verbose)
