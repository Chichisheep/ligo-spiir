#!/usr/bin/env python
#
# Copyright (C) 2010  Jordi Burguet-Castell
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Generate h(t).

It tries to mimic the behavior of LAL's ComputeStrain.c . It does not
compute the gamma factors for the moment.

It reads DARM_ERR and DARM_CTRL from H-H1_RDS_R_L1-943009024-64.gwf as
specified in data.cache. The filters file it uses is a npz version of
S6H1Filters_942436815.txt
"""

# To generate filters.npz you can use the program at
# gstlal/examples/utilities/calfilters2npz.py

# TODO:
#   make it work! (compared to dumped frame)

import sys
from numpy import load, atleast_2d

import pygtk
pygtk.require('2.0')
import pygst
pygst.require('0.10')
import gobject, gst
from gstlal.pipeutil import mkelem

mainloop = gobject.MainLoop()
pipeline = gst.Pipeline('calibration')

# Read filters file
filters = load('filters.npz')

# Time we use to start calibrating
ref_gpstime = 943009024
duration = 64


#
# Creation of the pipeline. We have to create the elements, and
# connect them in the right way.
#
# It will look like:
#
#   derr  -> 1/C              [1]  \
#                                   |->  [3] save
#   dctrl -> HPx2 -> AW -> A  [2]  /
#

# [1] Elements in the first path (from DARM_ERR channel)

derr_src = mkelem('lal_framesrc',
                  {'location': 'data.cache',
                   'channel-name': 'LSC-DARM_ERR',
                   'instrument': 'H1',
                   'blocksize': 524288})

pr1 = mkelem('progressreport', {'name': 'DARM_ERR progress'})

audioconvert1 = mkelem('audioconvert')  # lal_firbank only supports doubles

inv_sensing = mkelem('lal_firbank',
                     {'fir-matrix': atleast_2d(filters['inv_sensing'][::-1]),
                      'latency': -filters['inv_sens_delay']})

path1 = [derr_src, pr1, audioconvert1, inv_sensing]  # so we write less later


# [2] Elements in the second path (from DARM_CTRL channel)

dctrl_src = mkelem('lal_framesrc',
                   {'location': 'data.cache',
                    'channel-name': 'LSC-DARM_CTRL',
                    'instrument': 'H1',
                    'blocksize': 524288})

pr2 = mkelem('progressreport', {'name': 'DARM_CTRL progress'})

audioconvert2 = mkelem('audioconvert')  # lal_firbank only supports doubles

hpf = mkelem('audiowsinclimit',
             {'mode': 1,  # high pass filter
              'cutoff': 0.00244140625 * 16384/2,  # cf. ComputeStrain.c
              'length': 2*2000+1})

hpf2 = mkelem('audiowsinclimit',   # again! wish I could just copy it!
              {'mode': 1,
               'cutoff': 0.00244140625 * 16384/2,
               'length': 2*2000+1})

awhiten = mkelem('lal_firbank',
                 {'fir-matrix': atleast_2d(filters['awhitening'][::-1])})

actuation = mkelem('lal_firbank',
                   {'fir-matrix': atleast_2d(filters['actuation'][::-1])})

path2 = [dctrl_src, pr2, audioconvert2, hpf, hpf2, awhiten, actuation]


# [3] Elements from adder to saving the result

path3 = [mkelem(*x) for x in [ \
    ('lal_adder',   {}),
    ('lal_nxydump', {}),
    ('filesink',    {'location': 'gstlal_hoft.txt',
                     'sync': False,
                     'async': False}),
#        ('cairovis_lineseries', {}),
#        ('ffmpegcolorspace',    {}),
##        ('ximagesink',),
#        ('pngenc',              {}),
#        ('filesink', {'location': 'plot.png'}),
        ]]

#### For debugging stuff #####

#    ('lal_whiten',            {'zero-pad': 0,
#                               'fft-length': 1,
#                               'average-samples': 1,
#                               'median-samples': 1,
#                               'name': 'whiten'}),
#    ('fakesink',   {'sync': 0,
#                    'async': 0}),
#    ]

###############################


# Add to pipeline and link

pipeline.add(* path1 + path2 + path3)

gst.element_link_many(*path1)  # [1]
gst.element_link_many(*path2)  # [2]

path1[-1].link(path3[0])  # [1] \
                          #      |-> [3]
path2[-1].link(path3[0])  # [2] /

gst.element_link_many(*path3)  # [3]


#### For debugging stuff #####

def extract(pipeline, elem1, elem2, filename):
    """Take a couple of linked elements elem1->elem2 in a pipeline and
    extract the data flowing betweem them to a file."""
    tee = mkelem('tee')
    pipeline.add(tee)
    elem1.unlink(elem2)
    elem1.link(tee)
    tee.link(elem2)

    save_path = [mkelem(*x) for x in [ \
        ('queue',        {}),
        ('audioconvert', {}),
        ('lal_nxydump',  {}),
        ('filesink',    {'location': filename,
                         'sync': False,
                         'async': False})]]
    pipeline.add(*save_path)
    tee.link(save_path[0])
    gst.element_link_many(*save_path)

extract(pipeline, derr_src, pr1, 'gstlal_DARM_ERR.txt')
extract(pipeline, inv_sensing, path3[0], 'gstlal_C_inv_adv_DARM_ERR.txt')
extract(pipeline, dctrl_src, pr2, 'gstlal_DARM_CTRL.txt')
extract(pipeline, hpf2, awhiten, 'gstlal_HPFx2_adv_DARM_CTRL.txt')
extract(pipeline, awhiten, actuation, 'gstlal_AW_HPFx2_adv_DARM_CTRL.txt')
extract(pipeline, actuation, path3[0], 'gstlal_A_AW_HPFx2_adv_DARM_CTRL.txt')

##############################


# Make it start playing at the appropiate reference gpstime

path1[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
              gst.SEEK_TYPE_SET, ref_gpstime * 1e9,
              gst.SEEK_TYPE_SET, (ref_gpstime + duration) * 1e9)
path2[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
              gst.SEEK_TYPE_SET, ref_gpstime * 1e9,
              gst.SEEK_TYPE_SET, (ref_gpstime + duration) * 1e9)

# Boilerplate
class Handler(object):
    def __init__(self, mainloop, pipeline):
        self.mainloop = mainloop
        self.pipeline = pipeline

        bus = pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)

    def on_message(self, bus, message):
        if message.type == gst.MESSAGE_EOS:
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
        elif message.type == gst.MESSAGE_ERROR:
            gerr, dbgmsg = message.parse_error()
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
            sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg))

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
