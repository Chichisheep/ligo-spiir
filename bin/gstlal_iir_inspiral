#!/usr/bin/env python
#
# Copyright (C) 2011  Shaun Hooper, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""Stream-based inspiral analysis tool use IIR filters"""


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import sys
import scipy
import numpy
#import pylab
from optparse import OptionParser
from glue import segments
from pylal.datatypes import LIGOTimeGPS
from pylal.xlal.datatypes.snglinspiraltable import from_buffer as sngl_inspirals_from_buffer
from gstlal import ligolw_output


def parse_banks(bank_string):
	"""
	parses strings of form H1:bank1.xml,H2:bank2.xml,L1:bank3.xml,H2:bank4.xml,...
	"""
	out = {}
	if bank_string is None:
		return out
	for b in bank_string.split(','):
		ifo, bank = b.split(':')
		out.setdefault(ifo, []).append(bank)
	return out


#
# A function for parsing command line
#

def parse_command_line():
	parser = OptionParser(description = __doc__)
	parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache listing the LIGO-Virgo .gwf frame files (optional).  This is required unless --fake-data or --online-data is used in which case it must not be set.")
	parser.add_option("--fake-data", action = "store_true", help = "Instead of reading data from .gwf files, generate and process coloured Gaussian noise modelling the Initial LIGO design spectrum (optional).")
	parser.add_option("--iir-bank", metavar = "filenames", help = "Set the name of the LIGO light-weight XML file from which to load the iir template bank (required) format H1:bank1.xml,H2:bank2.xml,L1:bank3.xml,H2:bank4.xml,...")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load the injections (optional).")
	parser.add_option("--gps-start-time", help="GPS start time (required)", type="float")
	parser.add_option("--gps-end-time", help="GPS end time (required)", type="float")
	parser.add_option("--output", metavar = "filename", help = "Set the filename in which to save the triggers (required)")
	parser.add_option("--channel-name", metavar="channel", help="set the channel default LSC-STRAIN", default="LSC-STRAIN")
	parser.add_option("--tmp-space",  metavar="PATH")
	parser.add_option("--comment",  metavar="str")
	parser.add_option("--snr-threshold", metavar="float", help="SNR threshold default 5.5", default=5.5)
	parser.add_option("--reference-psd", metavar = "filename", help = "load the spectrum from this LIGO light-weight XML file (required).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
	
	options, filenames = parser.parse_args()

	if sum(1 for option in ('frame_cache', 'fake_data', ) if getattr(options, option) is not None) != 1: # FIXME: what about oline_data?
		raise ValueError, "must provide exactly one of --frame-cache, --fake-data"

	if options.frame_cache:
		required_options += ["channel_name", "gps_start_time", "gps_end_time"]

	fail = ""
	for option in ("iir_bank", "output", "gps_start_time", "gps_end_time"):
		if getattr(options, option) is None:
			fail += "must provide option %s\n" % (option)

	if fail: raise ValueError, fail
	
	effective_gps_start_time = LIGOTimeGPS(options.gps_start_time)
	effective_gps_end_time = LIGOTimeGPS(options.gps_end_time)

	process_params = ligolw_output.make_process_params(options) #FIXME override program name
	options.seg = segments.segment(effective_gps_start_time, effective_gps_end_time)

	return options, filenames, process_params

#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

#
# parse command line
#


options, filenames, process_params = parse_command_line()


#
# Import everything that depends on GStreamer
#

from gstlal import cbc_template_iir
from gstlal.pipeio import repack_complex_array_to_real, repack_real_array_to_complex
from gstlal.reference_psd import read_psd
from glue.ligolw import utils, param
from gstlal import pipeutil
from gstlal.lloidparts import seek_event_for_gps
from gstlal.pipeutil import gobject, gst
from gstlal import pipeparts
from gstlal import lloidparts


#
# extract parameters from the bank
#

banks = parse_banks(options.iir_bank)
snr_threshold = options.snr_threshold
# get the pipeline running
pipeline = gst.Pipeline("gstlal_iir_inspiral")
mainloop = gobject.MainLoop()
seekevent = seek_event_for_gps(options.gps_start_time, options.gps_end_time)
options.out_seg = segments.segment(options.seg[0], options.seg[1]) #FIXME make better outseg def.


def iir_bank(pipeline, head, sample_rates, a1, b0, delay):
	#FIXME don't upsample everything to a common rate
	max_rate = max(sample_rates)
	adder = gst.element_factory_make("lal_adder")
	pipeline.add(adder)
	for sr in sample_rates:
		head = pipeparts.mkiirbank(pipeline, head[sr], a1 = A[sr], b0 = B[sr], delay = D[sr])
		head = pipeparts.mkcapsfilter(pipeline, head, "audio/x-raw-float, rate=%d" % max_rate)
		adder.link(head)
	return adder

#
# loop over instruments FIXME for now it is just one instrument :)
#
detectors = {}
for ifo, bank in banks.items():
	detectors[ifo] = lloidparts.DetectorData(options.frame_cache, options.channel_name)

# FIXME ADD MORE
data = ligolw_output.Data(filename = options.output, instruments = set(detectors), seg = options.seg, out_seg = options.seg, injection_filename = options.injections)

#FIXME dont hardcode some of this
stream_thinca = lloidparts.StreamThinca(
	output,
	coincidence_threshold = 0.015,
	coincidence_back_off = 2 * 5,	# coincidence back-off is twice AppSync dt
	thinca_interval = 50.0	# seconds
)

appsinks = set()
triggersrc = set()
appsync = pipeparts.AppSync(appsink_new_buffer = stream_thinca.appsink_new_buffer, dt = 5)

for ifo, bank in banks.items():

	xmldoc = utils.load_filename(options.iir_bank, gz=options.iir_bank.endswith('.gz'))
	A, B, D, autocor = cbc_template_iir.get_matrices_from_xml(xmldoc)
	sample_rates = [int(s) for s in param.get_pyvalue(xmldoc, 'sample_rate').split(',')]


	head = lloidparts.mkLLOIDbasicsrc(
		pipeline,
		seekevent,
		ifo,
		detector = detectors[ifo],
		fake_data = options.fake_data,
		injection_filename = options.injections,
		verbose = options.verbose)

	head = lloidparts.mkLLOIDsrc(pipeline, head, sample_rates, psd=None, psd_fft_length = 8)

	# filter using IIR bank
	head = iir_bank(pipeline, head, sample_rates, a1 = A, b0 = B, delay = D) #FIXME should this be a1 = repack_complex_array_to_real(A)?

	head = pipeparts.mkqueue(pipeline, head)
	head = pipeparts.mktogglecomplex(pipeline, head)
	head = pipeparts.mknofakedisconts(pipeline, head)
	head = pipeparts.mkprogressreport(pipeline, head, "progressreport3")
	# tee off and write output file
	snr = chisq = pipeparts.mktee(pipeline, head)

	chisq = pipeparts.mkqueue(pipeline, chisq)
	chisq = pipeparts.mkautochisq(pipeline, chisq, autocorrelation_matrix = autocor, latency = -50, snr_thresh = snr_threshold)

	sigmasq=numpy.ones(len(autocor)) # FIXME: make sigmasq correct
	snr = pipeparts.mkqueue(pipeline, snr)

	triggergen = gst.element_factory_make("lal_triggergen")
	triggergen.set_property("bank-filename", options.iir_bank)
	triggergen.set_property("snr-thresh", snr_threshold)
	triggergen.set_property("sigmasq", sigmasq)
	triggergen.set_property("max-gap", 1.0)
	pipeline.add(triggergen)
	snr.link_pads("src", triggergen, "snr")
	chisq.link(triggergen)

# hook up the triggers
for trig in triggersrc:
	sink = appsync.add_sink(pipeline, pipeparts.mkqueue(pipeline, trig), caps = gst.Caps("application/x-lal-snglinspiral"))
	sink.connect_after("new-buffer", appsync.pull_appsinks_in_order)
	appsinks.add(sink)
	

############################################################
# run the pipeline

gst.DEBUG_BIN_TO_DOT_FILE(pipeline, gst.DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS, "gstlal_iir_inspiral_graph")

handler = lloidparts.LLOIDHandler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()

data.write_output_file()
